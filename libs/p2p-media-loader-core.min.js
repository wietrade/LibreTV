class D extends Error {
  constructor(t, e) {
    super(e), this.type = t, this.timestamp = performance.now();
  }
  timestamp;
}
class Oe extends Error {
  constructor(t) {
    super(), this.type = t;
  }
}
class as {
  constructor(t, e, n) {
    this.request = t, this.httpConfig = e, this.onChunkDownloaded = n.getEventDispatcher("onChunkDownloaded");
    const { byteRange: s } = this.request.segment;
    s && (this.requestByteRange = { ...s }), t.loadedBytes !== 0 && (this.requestByteRange = this.requestByteRange ?? { start: 0 }, this.requestByteRange.start = this.requestByteRange.start + t.loadedBytes), this.request.totalBytes && (this.expectedBytesLength = this.request.totalBytes - this.request.loadedBytes), this.requestControls = this.request.start({ downloadSource: "http" }, { abort: () => this.abortController.abort("abort"), notReceivingBytesTimeoutMs: this.httpConfig.httpNotReceivingBytesTimeoutMs }), this.fetch();
  }
  requestControls;
  abortController = new AbortController();
  expectedBytesLength;
  requestByteRange;
  onChunkDownloaded;
  async fetch() {
    const { segment: t } = this.request;
    try {
      let e = await this.httpConfig.httpRequestSetup?.(t.url, t.byteRange, this.abortController.signal, this.requestByteRange);
      if (!e) {
        const a = new Headers(this.requestByteRange ? { Range: `bytes=${this.requestByteRange.start}-${this.requestByteRange.end ?? ""}` } : void 0);
        e = new Request(t.url, { headers: a, signal: this.abortController.signal });
      }
      if (this.abortController.signal.aborted) throw new DOMException("Request aborted before request fetch", "AbortError");
      const n = await window.fetch(e);
      if (this.handleResponseHeaders(n), !n.body) return;
      const { requestControls: s } = this;
      s.firstBytesReceived();
      const o = n.body.getReader();
      for await (const a of (async function* (h) {
        for (; ; ) {
          const { done: l, value: c } = await h.read();
          if (l) break;
          yield c;
        }
      })(o)) this.requestControls.addLoadedChunk(a), this.onChunkDownloaded(a.byteLength, "http");
      if (!(await this.httpConfig.validateHTTPSegment?.(t.url, t.byteRange, this.request.data) ?? !0)) throw this.request.clearLoadedBytes(), new D("http-segment-validation-failed");
      s.completeOnSuccess();
    } catch (e) {
      this.handleError(e);
    }
  }
  handleResponseHeaders(t) {
    if (!t.ok) throw t.status === 406 ? (this.request.clearLoadedBytes(), new D("http-bytes-mismatch", t.statusText)) : new D("http-error", t.statusText);
    const { requestByteRange: e } = this;
    if (e) if (t.status === 200) {
      if (this.request.segment.byteRange) throw new D("http-unexpected-status-code");
      this.request.clearLoadedBytes();
    } else {
      if (t.status !== 206) throw new D("http-unexpected-status-code", t.statusText);
      const n = t.headers.get("Content-Length");
      if (n && this.expectedBytesLength !== void 0 && this.expectedBytesLength !== +n) throw this.request.clearLoadedBytes(), new D("http-bytes-mismatch", t.statusText);
      const s = t.headers.get("Content-Range"), o = s ? (function(a) {
        const h = hs.exec(a.trim());
        if (!h) return;
        const [, l, c, f] = h;
        return { from: l ? parseInt(l) : void 0, to: c ? parseInt(c) : void 0, total: f ? parseInt(f) : void 0 };
      })(s) : void 0;
      if (o) {
        const { from: a, to: h } = o, l = h !== void 0 && a !== void 0 ? h - a + 1 : void 0;
        if (l !== void 0 && this.expectedBytesLength !== l || a !== void 0 && e.start !== a || h !== void 0 && e.end !== void 0 && e.end !== h) throw this.request.clearLoadedBytes(), new D("http-bytes-mismatch", t.statusText);
      }
    }
    if (t.status === 200 && this.request.totalBytes === void 0) {
      const n = t.headers.get("Content-Length");
      n && this.request.setTotalBytes(+n);
    }
  }
  handleError(t) {
    if (t instanceof Error) {
      if (t.name !== "abort") return;
      const e = t instanceof D ? t : new D("http-error", t.message);
      this.requestControls.abortOnError(e);
    }
  }
}
const hs = /^bytes (?:(?:(\d+)|)-(?:(\d+)|)|\*)\/(?:(\d+)|\*)$/;
function ds(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var z, G, vn = { exports: {} }, P = vn.exports = {};
function oe() {
  throw new Error("setTimeout has not been defined");
}
function ae() {
  throw new Error("clearTimeout has not been defined");
}
function kn(i) {
  if (z === setTimeout) return setTimeout(i, 0);
  if ((z === oe || !z) && setTimeout) return z = setTimeout, setTimeout(i, 0);
  try {
    return z(i, 0);
  } catch {
    try {
      return z.call(null, i, 0);
    } catch {
      return z.call(this, i, 0);
    }
  }
}
(function() {
  try {
    z = typeof setTimeout == "function" ? setTimeout : oe;
  } catch {
    z = oe;
  }
  try {
    G = typeof clearTimeout == "function" ? clearTimeout : ae;
  } catch {
    G = ae;
  }
})();
var st, Y = [], ht = !1, Ot = -1;
function cs() {
  ht && st && (ht = !1, st.length ? Y = st.concat(Y) : Ot = -1, Y.length && Tn());
}
function Tn() {
  if (!ht) {
    var i = kn(cs);
    ht = !0;
    for (var t = Y.length; t; ) {
      for (st = Y, Y = []; ++Ot < t; ) st && st[Ot].run();
      Ot = -1, t = Y.length;
    }
    st = null, ht = !1, (function(e) {
      if (G === clearTimeout) return clearTimeout(e);
      if ((G === ae || !G) && clearTimeout) return G = clearTimeout, clearTimeout(e);
      try {
        return G(e);
      } catch {
        try {
          return G.call(null, e);
        } catch {
          return G.call(this, e);
        }
      }
    })(i);
  }
}
function De(i, t) {
  this.fun = i, this.array = t;
}
function W() {
}
P.nextTick = function(i) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
  Y.push(new De(i, t)), Y.length !== 1 || ht || kn(Tn);
}, De.prototype.run = function() {
  this.fun.apply(null, this.array);
}, P.title = "browser", P.browser = !0, P.env = {}, P.argv = [], P.version = "", P.versions = {}, P.on = W, P.addListener = W, P.once = W, P.off = W, P.removeListener = W, P.removeAllListeners = W, P.emit = W, P.prependListener = W, P.prependOnceListener = W, P.listeners = function(i) {
  return [];
}, P.binding = function(i) {
  throw new Error("process.binding is not supported");
}, P.cwd = function() {
  return "/";
}, P.chdir = function(i) {
  throw new Error("process.chdir is not supported");
}, P.umask = function() {
  return 0;
};
const Dt = ds(vn.exports);
var xn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function it(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Ne, Me, Fe, Ue, He, Zt = { exports: {} };
function ls() {
  if (Me) return Ne;
  Me = 1;
  var i = 1e3, t = 60 * i, e = 60 * t, n = 24 * e, s = 7 * n, o = 365.25 * n;
  function a(h, l, c, f) {
    var S = l >= 1.5 * c;
    return Math.round(h / c) + " " + f + (S ? "s" : "");
  }
  return Ne = function(h, l) {
    l = l || {};
    var c = typeof h;
    if (c === "string" && h.length > 0) return (function(f) {
      if (!((f = String(f)).length > 100)) {
        var S = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(f);
        if (S) {
          var C = parseFloat(S[1]);
          switch ((S[2] || "ms").toLowerCase()) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return C * o;
            case "weeks":
            case "week":
            case "w":
              return C * s;
            case "days":
            case "day":
            case "d":
              return C * n;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return C * e;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return C * t;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return C * i;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return C;
            default:
              return;
          }
        }
      }
    })(h);
    if (c === "number" && isFinite(h)) return l.long ? (function(f) {
      var S = Math.abs(f);
      return S >= n ? a(f, S, n, "day") : S >= e ? a(f, S, e, "hour") : S >= t ? a(f, S, t, "minute") : S >= i ? a(f, S, i, "second") : f + " ms";
    })(h) : (function(f) {
      var S = Math.abs(f);
      return S >= n ? Math.round(f / n) + "d" : S >= e ? Math.round(f / e) + "h" : S >= t ? Math.round(f / t) + "m" : S >= i ? Math.round(f / i) + "s" : f + "ms";
    })(h);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(h));
  };
}
var An = (He || (He = 1, (function(i, t) {
  t.formatArgs = function(n) {
    if (n[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + n[0] + (this.useColors ? "%c " : " ") + "+" + i.exports.humanize(this.diff), !this.useColors) return;
    const s = "color: " + this.color;
    n.splice(1, 0, s, "color: inherit");
    let o = 0, a = 0;
    n[0].replace(/%[a-zA-Z%]/g, (h) => {
      h !== "%%" && (o++, h === "%c" && (a = o));
    }), n.splice(a, 0, s);
  }, t.save = function(n) {
    try {
      n ? t.storage.setItem("debug", n) : t.storage.removeItem("debug");
    } catch {
    }
  }, t.load = function() {
    let n;
    try {
      n = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
    } catch {
    }
    return !n && Dt !== void 0 && "env" in Dt && (n = Dt.env.DEBUG), n;
  }, t.useColors = function() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
    let n;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (n = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(n[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }, t.storage = (function() {
    try {
      return localStorage;
    } catch {
    }
  })(), t.destroy = /* @__PURE__ */ (() => {
    let n = !1;
    return () => {
      n || (n = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {
  }), i.exports = (Ue || (Ue = 1, Fe = function(n) {
    function s(h) {
      let l, c, f, S = null;
      function C(...k) {
        if (!C.enabled) return;
        const L = C, m = Number(/* @__PURE__ */ new Date()), u = m - (l || m);
        L.diff = u, L.prev = l, L.curr = m, l = m, k[0] = s.coerce(k[0]), typeof k[0] != "string" && k.unshift("%O");
        let d = 0;
        k[0] = k[0].replace(/%([a-zA-Z%])/g, (g, _) => {
          if (g === "%%") return "%";
          d++;
          const p = s.formatters[_];
          if (typeof p == "function") {
            const y = k[d];
            g = p.call(L, y), k.splice(d, 1), d--;
          }
          return g;
        }), s.formatArgs.call(L, k), (L.log || s.log).apply(L, k);
      }
      return C.namespace = h, C.useColors = s.useColors(), C.color = s.selectColor(h), C.extend = o, C.destroy = s.destroy, Object.defineProperty(C, "enabled", { enumerable: !0, configurable: !1, get: () => S !== null ? S : (c !== s.namespaces && (c = s.namespaces, f = s.enabled(h)), f), set: (k) => {
        S = k;
      } }), typeof s.init == "function" && s.init(C), C;
    }
    function o(h, l) {
      const c = s(this.namespace + (l === void 0 ? ":" : l) + h);
      return c.log = this.log, c;
    }
    function a(h, l) {
      let c = 0, f = 0, S = -1, C = 0;
      for (; c < h.length; ) if (f < l.length && (l[f] === h[c] || l[f] === "*")) l[f] === "*" ? (S = f, C = c, f++) : (c++, f++);
      else {
        if (S === -1) return !1;
        f = S + 1, C++, c = C;
      }
      for (; f < l.length && l[f] === "*"; ) f++;
      return f === l.length;
    }
    return s.debug = s, s.default = s, s.coerce = function(h) {
      return h instanceof Error ? h.stack || h.message : h;
    }, s.disable = function() {
      const h = [...s.names, ...s.skips.map((l) => "-" + l)].join(",");
      return s.enable(""), h;
    }, s.enable = function(h) {
      s.save(h), s.namespaces = h, s.names = [], s.skips = [];
      const l = (typeof h == "string" ? h : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const c of l) c[0] === "-" ? s.skips.push(c.slice(1)) : s.names.push(c);
    }, s.enabled = function(h) {
      for (const l of s.skips) if (a(h, l)) return !1;
      for (const l of s.names) if (a(h, l)) return !0;
      return !1;
    }, s.humanize = ls(), s.destroy = function() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }, Object.keys(n).forEach((h) => {
      s[h] = n[h];
    }), s.names = [], s.skips = [], s.formatters = {}, s.selectColor = function(h) {
      let l = 0;
      for (let c = 0; c < h.length; c++) l = (l << 5) - l + h.charCodeAt(c), l |= 0;
      return s.colors[Math.abs(l) % s.colors.length];
    }, s.enable(s.load()), s;
  }), Fe)(t);
  const { formatters: e } = i.exports;
  e.j = function(n) {
    try {
      return JSON.stringify(n);
    } catch (s) {
      return "[UnexpectedJSONParseError]: " + s.message;
    }
  };
})(Zt, Zt.exports)), Zt.exports);
const U = it(An);
var $e, At = { exports: {} };
function Ln() {
  if ($e) return At.exports;
  $e = 1;
  var i, t = typeof Reflect == "object" ? Reflect : null, e = t && typeof t.apply == "function" ? t.apply : function(m, u, d) {
    return Function.prototype.apply.call(m, u, d);
  };
  i = t && typeof t.ownKeys == "function" ? t.ownKeys : Object.getOwnPropertySymbols ? function(m) {
    return Object.getOwnPropertyNames(m).concat(Object.getOwnPropertySymbols(m));
  } : function(m) {
    return Object.getOwnPropertyNames(m);
  };
  var n = Number.isNaN || function(m) {
    return m != m;
  };
  function s() {
    s.init.call(this);
  }
  At.exports = s, At.exports.once = function(m, u) {
    return new Promise(function(d, g) {
      function _(y) {
        m.removeListener(u, p), g(y);
      }
      function p() {
        typeof m.removeListener == "function" && m.removeListener("error", _), d([].slice.call(arguments));
      }
      L(m, u, p, { once: !0 }), u !== "error" && (function(y, T, B) {
        typeof y.on == "function" && L(y, "error", T, B);
      })(m, _, { once: !0 });
    });
  }, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var o = 10;
  function a(m) {
    if (typeof m != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof m);
  }
  function h(m) {
    return m._maxListeners === void 0 ? s.defaultMaxListeners : m._maxListeners;
  }
  function l(m, u, d, g) {
    var _, p, y, T;
    if (a(d), (p = m._events) === void 0 ? (p = m._events = /* @__PURE__ */ Object.create(null), m._eventsCount = 0) : (p.newListener !== void 0 && (m.emit("newListener", u, d.listener ? d.listener : d), p = m._events), y = p[u]), y === void 0) y = p[u] = d, ++m._eventsCount;
    else if (typeof y == "function" ? y = p[u] = g ? [d, y] : [y, d] : g ? y.unshift(d) : y.push(d), (_ = h(m)) > 0 && y.length > _ && !y.warned) {
      y.warned = !0;
      var B = new Error("Possible EventEmitter memory leak detected. " + y.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      B.name = "MaxListenersExceededWarning", B.emitter = m, B.type = u, B.count = y.length, T = B, console && console.warn && console.warn(T);
    }
    return m;
  }
  function c() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function f(m, u, d) {
    var g = { fired: !1, wrapFn: void 0, target: m, type: u, listener: d }, _ = c.bind(g);
    return _.listener = d, g.wrapFn = _, _;
  }
  function S(m, u, d) {
    var g = m._events;
    if (g === void 0) return [];
    var _ = g[u];
    return _ === void 0 ? [] : typeof _ == "function" ? d ? [_.listener || _] : [_] : d ? (function(p) {
      for (var y = new Array(p.length), T = 0; T < y.length; ++T) y[T] = p[T].listener || p[T];
      return y;
    })(_) : k(_, _.length);
  }
  function C(m) {
    var u = this._events;
    if (u !== void 0) {
      var d = u[m];
      if (typeof d == "function") return 1;
      if (d !== void 0) return d.length;
    }
    return 0;
  }
  function k(m, u) {
    for (var d = new Array(u), g = 0; g < u; ++g) d[g] = m[g];
    return d;
  }
  function L(m, u, d, g) {
    if (typeof m.on == "function") g.once ? m.once(u, d) : m.on(u, d);
    else {
      if (typeof m.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof m);
      m.addEventListener(u, function _(p) {
        g.once && m.removeEventListener(u, _), d(p);
      });
    }
  }
  return Object.defineProperty(s, "defaultMaxListeners", { enumerable: !0, get: function() {
    return o;
  }, set: function(m) {
    if (typeof m != "number" || m < 0 || n(m)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + m + ".");
    o = m;
  } }), s.init = function() {
    this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(m) {
    if (typeof m != "number" || m < 0 || n(m)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + m + ".");
    return this._maxListeners = m, this;
  }, s.prototype.getMaxListeners = function() {
    return h(this);
  }, s.prototype.emit = function(m) {
    for (var u = [], d = 1; d < arguments.length; d++) u.push(arguments[d]);
    var g = m === "error", _ = this._events;
    if (_ !== void 0) g = g && _.error === void 0;
    else if (!g) return !1;
    if (g) {
      var p;
      if (u.length > 0 && (p = u[0]), p instanceof Error) throw p;
      var y = new Error("Unhandled error." + (p ? " (" + p.message + ")" : ""));
      throw y.context = p, y;
    }
    var T = _[m];
    if (T === void 0) return !1;
    if (typeof T == "function") e(T, this, u);
    else {
      var B = T.length, rt = k(T, B);
      for (d = 0; d < B; ++d) e(rt[d], this, u);
    }
    return !0;
  }, s.prototype.addListener = function(m, u) {
    return l(this, m, u, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(m, u) {
    return l(this, m, u, !0);
  }, s.prototype.once = function(m, u) {
    return a(u), this.on(m, f(this, m, u)), this;
  }, s.prototype.prependOnceListener = function(m, u) {
    return a(u), this.prependListener(m, f(this, m, u)), this;
  }, s.prototype.removeListener = function(m, u) {
    var d, g, _, p, y;
    if (a(u), (g = this._events) === void 0) return this;
    if ((d = g[m]) === void 0) return this;
    if (d === u || d.listener === u) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete g[m], g.removeListener && this.emit("removeListener", m, d.listener || u));
    else if (typeof d != "function") {
      for (_ = -1, p = d.length - 1; p >= 0; p--) if (d[p] === u || d[p].listener === u) {
        y = d[p].listener, _ = p;
        break;
      }
      if (_ < 0) return this;
      _ === 0 ? d.shift() : (function(T, B) {
        for (; B + 1 < T.length; B++) T[B] = T[B + 1];
        T.pop();
      })(d, _), d.length === 1 && (g[m] = d[0]), g.removeListener !== void 0 && this.emit("removeListener", m, y || u);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(m) {
    var u, d, g;
    if ((d = this._events) === void 0) return this;
    if (d.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : d[m] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete d[m]), this;
    if (arguments.length === 0) {
      var _, p = Object.keys(d);
      for (g = 0; g < p.length; ++g) (_ = p[g]) !== "removeListener" && this.removeAllListeners(_);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (typeof (u = d[m]) == "function") this.removeListener(m, u);
    else if (u !== void 0) for (g = u.length - 1; g >= 0; g--) this.removeListener(m, u[g]);
    return this;
  }, s.prototype.listeners = function(m) {
    return S(this, m, !0);
  }, s.prototype.rawListeners = function(m) {
    return S(this, m, !1);
  }, s.listenerCount = function(m, u) {
    return typeof m.listenerCount == "function" ? m.listenerCount(u) : C.call(m, u);
  }, s.prototype.listenerCount = C, s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? i(this._events) : [];
  }, At.exports;
}
const In = it(Ln());
var je, We, Qe, Lt = { exports: {} }, us = (function() {
  if (Qe) return Lt.exports;
  Qe = 1;
  var i = (We || (We = 1, je = function n(s, o) {
    if (s && o) return n(s)(o);
    if (typeof s != "function") throw new TypeError("need wrapper function");
    return Object.keys(s).forEach(function(h) {
      a[h] = s[h];
    }), a;
    function a() {
      for (var h = new Array(arguments.length), l = 0; l < h.length; l++) h[l] = arguments[l];
      var c = s.apply(this, h), f = h[h.length - 1];
      return typeof c == "function" && c !== f && Object.keys(f).forEach(function(S) {
        c[S] = f[S];
      }), c;
    }
  }), je);
  function t(n) {
    var s = function() {
      return s.called ? s.value : (s.called = !0, s.value = n.apply(this, arguments));
    };
    return s.called = !1, s;
  }
  function e(n) {
    var s = function() {
      if (s.called) throw new Error(s.onceError);
      return s.called = !0, s.value = n.apply(this, arguments);
    }, o = n.name || "Function wrapped with `once`";
    return s.onceError = o + " shouldn't be called more than once", s.called = !1, s;
  }
  return Lt.exports = i(t), Lt.exports.strict = i(e), t.proto = t(function() {
    Object.defineProperty(Function.prototype, "once", { value: function() {
      return t(this);
    }, configurable: !0 }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
      return e(this);
    }, configurable: !0 });
  }), Lt.exports;
})();
const gs = it(us);
var ze, Ge, Xt, Ye;
function En() {
  if (Ge) return ze;
  let i;
  return Ge = 1, ze = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : xn) : (t) => (i || (i = Promise.resolve())).then(t).catch((e) => setTimeout(() => {
    throw e;
  }, 0));
}
var ms = (function() {
  if (Ye) return Xt;
  Ye = 1, Xt = function(t, e) {
    let n, s, o, a = !0;
    Array.isArray(t) ? (n = [], s = t.length) : (o = Object.keys(t), n = {}, s = o.length);
    function h(c) {
      function f() {
        e && e(c, n), e = null;
      }
      a ? i(f) : f();
    }
    function l(c, f, S) {
      n[c] = S, (--s === 0 || f) && h(f);
    }
    s ? o ? o.forEach(function(c) {
      t[c](function(f, S) {
        l(c, f, S);
      });
    }) : t.forEach(function(c, f) {
      c(function(S, C) {
        l(f, S, C);
      });
    }) : h(null), a = !1;
  };
  const i = En();
  return Xt;
})();
const ps = it(ms), V = typeof window < "u" ? window : self, he = V.RTCPeerConnection || V.mozRTCPeerConnection || V.webkitRTCPeerConnection, fs = V.RTCSessionDescription || V.mozRTCSessionDescription || V.webkitRTCSessionDescription, _s = V.RTCIceCandidate || V.mozRTCIceCandidate || V.webkitRTCIceCandidate;
var Je, Ve, Ke, Ze, Xe, tn, en, nn, sn, rn, on, an;
function ys() {
  if (tn) return Xe;
  tn = 1;
  const i = Ze ? Ke : (Ze = 1, Ke = class {
    constructor(t) {
      if (!(t > 0) || t - 1 & t) throw new Error("Max size for a FixedFIFO should be a power of two");
      this.buffer = new Array(t), this.mask = t - 1, this.top = 0, this.btm = 0, this.next = null;
    }
    clear() {
      this.top = this.btm = 0, this.next = null, this.buffer.fill(void 0);
    }
    push(t) {
      return this.buffer[this.top] === void 0 && (this.buffer[this.top] = t, this.top = this.top + 1 & this.mask, !0);
    }
    shift() {
      const t = this.buffer[this.btm];
      if (t !== void 0) return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, t;
    }
    peek() {
      return this.buffer[this.btm];
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  });
  return Xe = class {
    constructor(t) {
      this.hwm = t || 16, this.head = new i(this.hwm), this.tail = this.head, this.length = 0;
    }
    clear() {
      this.head = this.tail, this.head.clear(), this.length = 0;
    }
    push(t) {
      if (this.length++, !this.head.push(t)) {
        const e = this.head;
        this.head = e.next = new i(2 * this.head.buffer.length), this.head.push(t);
      }
    }
    shift() {
      this.length !== 0 && this.length--;
      const t = this.tail.shift();
      if (t === void 0 && this.tail.next) {
        const e = this.tail.next;
        return this.tail.next = null, this.tail = e, this.tail.shift();
      }
      return t;
    }
    peek() {
      const t = this.tail.peek();
      return t === void 0 && this.tail.next ? this.tail.next.peek() : t;
    }
    isEmpty() {
      return this.length === 0;
    }
  };
}
function hn() {
  return nn ? en : (nn = 1, en = class {
    constructor(i) {
      this.decoder = new TextDecoder(i === "utf16le" ? "utf16-le" : i);
    }
    get remaining() {
      return -1;
    }
    decode(i) {
      return this.decoder.decode(i, { stream: !0 });
    }
    flush() {
      return this.decoder.decode(new Uint8Array(0));
    }
  });
}
function Ss() {
  if (rn) return sn;
  rn = 1;
  const i = hn(), t = hn();
  return sn = class {
    constructor(e = "utf8") {
      switch (this.encoding = (function(n) {
        switch (n = n.toLowerCase()) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return n;
          default:
            throw new Error("Unknown encoding: " + n);
        }
      })(e), this.encoding) {
        case "utf8":
          this.decoder = new t();
          break;
        case "utf16le":
        case "base64":
          throw new Error("Unsupported encoding: " + this.encoding);
        default:
          this.decoder = new i(this.encoding);
      }
    }
    get remaining() {
      return this.decoder.remaining;
    }
    push(e) {
      return typeof e == "string" ? e : this.decoder.decode(e);
    }
    write(e) {
      return this.push(e);
    }
    end(e) {
      let n = "";
      return e && (n = this.push(e)), n += this.decoder.flush(), n;
    }
  };
}
var dn, cn, Rn = (function() {
  if (an) return on;
  an = 1;
  const { EventEmitter: i } = Ve ? Je : (Ve = 1, Je = Ln()), t = new Error("Stream was destroyed"), e = new Error("Premature close"), n = ys(), s = Ss(), o = typeof queueMicrotask > "u" ? (b) => xn.process.nextTick(b) : queueMicrotask, a = 536870911, h = 1 ^ a, l = 2 ^ a, c = 32, f = 64, S = 128, C = 256, k = 1024, L = 2048, m = 4096, u = 8192, d = 16384, g = 32768, _ = 131072, p = 131328, y = 16 ^ a, T = 536805375, B = 768 ^ a, rt = 536838143, kt = 536739839, Qt = 1 << 18, H = 2 << 18, $ = 4 << 18, M = 8 << 18, ot = 16 << 18, K = 32 << 18, j = 64 << 18, gt = 128 << 18, $n = 256 << 18, Se = 512 << 18, we = 1024 << 18, jn = 535822335, be = 503316479, Ce = 268435455, Tt = 262160, Wn = 536608751, ve = 8404992, mt = 14, Qn = 15, ke = 8405006, zt = 33587200, Te = 33587215, zn = 2359296, xe = 270794767, xt = Symbol.asyncIterator || Symbol("asyncIterator");
  class Ae {
    constructor(r, { highWaterMark: w = 16384, map: v = null, mapWritable: x, byteLength: A, byteLengthWritable: I } = {}) {
      this.stream = r, this.queue = new n(), this.highWaterMark = w, this.buffered = 0, this.error = null, this.pipeline = null, this.drains = null, this.byteLength = I || A || Be, this.map = x || v, this.afterWrite = Zn.bind(this), this.afterUpdateNextTick = es.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & K) !== 0;
    }
    push(r) {
      return !(142606350 & this.stream._duplexState) && (this.map !== null && (r = this.map(r)), this.buffered += this.byteLength(r), this.queue.push(r), this.buffered < this.highWaterMark ? (this.stream._duplexState |= M, !0) : (this.stream._duplexState |= 6291456, !1));
    }
    shift() {
      const r = this.queue.shift();
      return this.buffered -= this.byteLength(r), this.buffered === 0 && (this.stream._duplexState &= 534773759), r;
    }
    end(r) {
      typeof r == "function" ? this.stream.once("finish", r) : r != null && this.push(r), this.stream._duplexState = (this.stream._duplexState | Se) & jn;
    }
    autoBatch(r, w) {
      const v = [], x = this.stream;
      for (v.push(r); (x._duplexState & xe) === zn; ) v.push(x._writableState.shift());
      if ((x._duplexState & Qn) !== 0) return w(null);
      x._writev(v, w);
    }
    update() {
      const r = this.stream;
      r._duplexState |= H;
      do {
        for (; (r._duplexState & xe) === M; ) {
          const w = this.shift();
          r._duplexState |= 67371008, r._write(w, this.afterWrite);
        }
        1310720 & r._duplexState || this.updateNonPrimary();
      } while (this.continueUpdate() === !0);
      r._duplexState &= 536346623;
    }
    updateNonPrimary() {
      const r = this.stream;
      if ((144965647 & r._duplexState) === Se) return r._duplexState = r._duplexState | Qt, void r._final(Kn.bind(this));
      (r._duplexState & mt) !== 4 ? (r._duplexState & Te) === 1 && (r._duplexState = (r._duplexState | Tt) & h, r._open(Ie.bind(this))) : (r._duplexState & zt) === 0 && (r._duplexState |= Tt, r._destroy(Le.bind(this)));
    }
    continueUpdate() {
      return (this.stream._duplexState & gt) !== 0 && (this.stream._duplexState &= be, !0);
    }
    updateCallback() {
      (35127311 & this.stream._duplexState) === $ ? this.update() : this.updateNextTick();
    }
    updateNextTick() {
      (this.stream._duplexState & gt) === 0 && (this.stream._duplexState |= gt, (this.stream._duplexState & H) === 0 && o(this.afterUpdateNextTick));
    }
  }
  class Gn {
    constructor(r, { highWaterMark: w = 16384, map: v = null, mapReadable: x, byteLength: A, byteLengthReadable: I } = {}) {
      this.stream = r, this.queue = new n(), this.highWaterMark = w === 0 ? 1 : w, this.buffered = 0, this.readAhead = w > 0, this.error = null, this.pipeline = null, this.byteLength = I || A || Be, this.map = x || v, this.pipeTo = null, this.afterRead = Xn.bind(this), this.afterUpdateNextTick = ts.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & d) !== 0;
    }
    pipe(r, w) {
      if (this.pipeTo !== null) throw new Error("Can only pipe to one destination");
      if (typeof w != "function" && (w = null), this.stream._duplexState |= 512, this.pipeTo = r, this.pipeline = new Jn(this.stream, r, w), w && this.stream.on("error", qe), ft(r)) r._writableState.pipeline = this.pipeline, w && r.on("error", qe), r.on("finish", this.pipeline.finished.bind(this.pipeline));
      else {
        const v = this.pipeline.done.bind(this.pipeline, r), x = this.pipeline.done.bind(this.pipeline, r, null);
        r.on("error", v), r.on("close", x), r.on("finish", this.pipeline.finished.bind(this.pipeline));
      }
      r.on("drain", Vn.bind(this)), this.stream.emit("piping", r), r.emit("pipe", this.stream);
    }
    push(r) {
      const w = this.stream;
      return r === null ? (this.highWaterMark = 0, w._duplexState = 536805311 & w._duplexState | 1024, !1) : this.map !== null && (r = this.map(r)) === null ? (w._duplexState &= T, this.buffered < this.highWaterMark) : (this.buffered += this.byteLength(r), this.queue.push(r), w._duplexState = (w._duplexState | S) & T, this.buffered < this.highWaterMark);
    }
    shift() {
      const r = this.queue.shift();
      return this.buffered -= this.byteLength(r), this.buffered === 0 && (this.stream._duplexState &= 536862591), r;
    }
    unshift(r) {
      const w = [this.map !== null ? this.map(r) : r];
      for (; this.buffered > 0; ) w.push(this.shift());
      for (let v = 0; v < w.length - 1; v++) {
        const x = w[v];
        this.buffered += this.byteLength(x), this.queue.push(x);
      }
      this.push(w[w.length - 1]);
    }
    read() {
      const r = this.stream;
      if ((16527 & r._duplexState) === S) {
        const w = this.shift();
        return this.pipeTo !== null && this.pipeTo.write(w) === !1 && (r._duplexState &= B), (r._duplexState & L) !== 0 && r.emit("data", w), w;
      }
      return this.readAhead === !1 && (r._duplexState |= _, this.updateNextTick()), null;
    }
    drain() {
      const r = this.stream;
      for (; (16527 & r._duplexState) === S && 768 & r._duplexState; ) {
        const w = this.shift();
        this.pipeTo !== null && this.pipeTo.write(w) === !1 && (r._duplexState &= B), (r._duplexState & L) !== 0 && r.emit("data", w);
      }
    }
    update() {
      const r = this.stream;
      r._duplexState |= c;
      do {
        for (this.drain(); this.buffered < this.highWaterMark && (214047 & r._duplexState) === _; ) r._duplexState |= 65552, r._read(this.afterRead), this.drain();
        (12431 & r._duplexState) == 4224 && (r._duplexState |= u, r.emit("readable")), 80 & r._duplexState || this.updateNonPrimary();
      } while (this.continueUpdate() === !0);
      r._duplexState &= 536870879;
    }
    updateNonPrimary() {
      const r = this.stream;
      (1167 & r._duplexState) === k && (r._duplexState = 536869887 & r._duplexState | 16384, r.emit("end"), (r._duplexState & ke) === ve && (r._duplexState |= 4), this.pipeTo !== null && this.pipeTo.end()), (r._duplexState & mt) !== 4 ? (r._duplexState & Te) === 1 && (r._duplexState = (r._duplexState | Tt) & h, r._open(Ie.bind(this))) : (r._duplexState & zt) === 0 && (r._duplexState |= Tt, r._destroy(Le.bind(this)));
    }
    continueUpdate() {
      return (this.stream._duplexState & g) !== 0 && (this.stream._duplexState &= rt, !0);
    }
    updateCallback() {
      (32879 & this.stream._duplexState) === f ? this.update() : this.updateNextTick();
    }
    updateNextTickIfOpen() {
      32769 & this.stream._duplexState || (this.stream._duplexState |= g, (this.stream._duplexState & c) === 0 && o(this.afterUpdateNextTick));
    }
    updateNextTick() {
      (this.stream._duplexState & g) === 0 && (this.stream._duplexState |= g, (this.stream._duplexState & c) === 0 && o(this.afterUpdateNextTick));
    }
  }
  class Yn {
    constructor(r) {
      this.data = null, this.afterTransform = ns.bind(r), this.afterFinal = null;
    }
  }
  class Jn {
    constructor(r, w, v) {
      this.from = r, this.to = w, this.afterPipe = v, this.error = null, this.pipeToFinished = !1;
    }
    finished() {
      this.pipeToFinished = !0;
    }
    done(r, w) {
      w && (this.error = w), r !== this.to || (this.to = null, this.from === null) ? r !== this.from || (this.from = null, this.to === null) ? (this.afterPipe !== null && this.afterPipe(this.error), this.to = this.from = this.afterPipe = null) : (r._duplexState & d) === 0 && this.to.destroy(this.error || new Error("Readable stream closed before ending")) : (this.from._duplexState & d) !== 0 && this.pipeToFinished || this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
    }
  }
  function Vn() {
    this.stream._duplexState |= 512, this.updateCallback();
  }
  function Kn(b) {
    const r = this.stream;
    b && r.destroy(b), (r._duplexState & mt) === 0 && (r._duplexState |= K, r.emit("finish")), (r._duplexState & ke) === ve && (r._duplexState |= 4), r._duplexState &= 402391039, (r._duplexState & H) === 0 ? this.update() : this.updateNextTick();
  }
  function Le(b) {
    const r = this.stream;
    b || this.error === t || (b = this.error), b && r.emit("error", b), r._duplexState |= 8, r.emit("close");
    const w = r._readableState, v = r._writableState;
    if (w !== null && w.pipeline !== null && w.pipeline.done(r, b), v !== null) {
      for (; v.drains !== null && v.drains.length > 0; ) v.drains.shift().resolve(!1);
      v.pipeline !== null && v.pipeline.done(r, b);
    }
  }
  function Zn(b) {
    const r = this.stream;
    b && r.destroy(b), r._duplexState &= 469499903, this.drains !== null && (function(w) {
      for (let v = 0; v < w.length; v++) --w[v].writes === 0 && (w.shift().resolve(!0), v--);
    })(this.drains), (6553615 & r._duplexState) === ot && (r._duplexState &= 532676607, (r._duplexState & j) === j && r.emit("drain")), this.updateCallback();
  }
  function Xn(b) {
    b && this.stream.destroy(b), this.stream._duplexState &= y, this.readAhead === !1 && (this.stream._duplexState & C) === 0 && (this.stream._duplexState &= kt), this.updateCallback();
  }
  function ts() {
    (this.stream._duplexState & c) === 0 && (this.stream._duplexState &= rt, this.update());
  }
  function es() {
    (this.stream._duplexState & H) === 0 && (this.stream._duplexState &= be, this.update());
  }
  function Ie(b) {
    const r = this.stream;
    b && r.destroy(b), 4 & r._duplexState || (17423 & r._duplexState || (r._duplexState |= f), 142606351 & r._duplexState || (r._duplexState |= $), r.emit("open")), r._duplexState &= Wn, r._writableState !== null && r._writableState.updateCallback(), r._readableState !== null && r._readableState.updateCallback();
  }
  function ns(b, r) {
    r != null && this.push(r), this._writableState.afterWrite(b);
  }
  function ss(b) {
    this._readableState !== null && (b === "data" && (this._duplexState |= 133376, this._readableState.updateNextTick()), b === "readable" && (this._duplexState |= m, this._readableState.updateNextTick())), this._writableState !== null && b === "drain" && (this._duplexState |= j, this._writableState.updateNextTick());
  }
  class Gt extends i {
    constructor(r) {
      super(), this._duplexState = 0, this._readableState = null, this._writableState = null, r && (r.open && (this._open = r.open), r.destroy && (this._destroy = r.destroy), r.predestroy && (this._predestroy = r.predestroy), r.signal && r.signal.addEventListener("abort", os.bind(this))), this.on("newListener", ss);
    }
    _open(r) {
      r(null);
    }
    _destroy(r) {
      r(null);
    }
    _predestroy() {
    }
    get readable() {
      return this._readableState !== null || void 0;
    }
    get writable() {
      return this._writableState !== null || void 0;
    }
    get destroyed() {
      return !!(8 & this._duplexState);
    }
    get destroying() {
      return (this._duplexState & mt) !== 0;
    }
    destroy(r) {
      (this._duplexState & mt) === 0 && (r || (r = t), this._duplexState = 535822271 & this._duplexState | 4, this._readableState !== null && (this._readableState.highWaterMark = 0, this._readableState.error = r), this._writableState !== null && (this._writableState.highWaterMark = 0, this._writableState.error = r), this._duplexState |= 2, this._predestroy(), this._duplexState &= l, this._readableState !== null && this._readableState.updateNextTick(), this._writableState !== null && this._writableState.updateNextTick());
    }
  }
  class pt extends Gt {
    constructor(r) {
      super(r), this._duplexState |= 8519681, this._readableState = new Gn(this, r), r && (this._readableState.readAhead === !1 && (this._duplexState &= kt), r.read && (this._read = r.read), r.eagerOpen && this._readableState.updateNextTick(), r.encoding && this.setEncoding(r.encoding));
    }
    setEncoding(r) {
      const w = new s(r), v = this._readableState.map || rs;
      return this._readableState.map = function(x) {
        const A = w.push(x);
        return A === "" && (x.byteLength !== 0 || w.remaining > 0) ? null : v(A);
      }, this;
    }
    _read(r) {
      r(null);
    }
    pipe(r, w) {
      return this._readableState.updateNextTick(), this._readableState.pipe(r, w), r;
    }
    read() {
      return this._readableState.updateNextTick(), this._readableState.read();
    }
    push(r) {
      return this._readableState.updateNextTickIfOpen(), this._readableState.push(r);
    }
    unshift(r) {
      return this._readableState.updateNextTickIfOpen(), this._readableState.unshift(r);
    }
    resume() {
      return this._duplexState |= p, this._readableState.updateNextTick(), this;
    }
    pause() {
      return this._duplexState &= this._readableState.readAhead === !1 ? 536739583 : 536870655, this;
    }
    static _fromAsyncIterator(r, w) {
      let v;
      const x = new pt({ ...w, read(I) {
        r.next().then(A).then(I.bind(null, null)).catch(I);
      }, predestroy() {
        v = r.return();
      }, destroy(I) {
        if (!v) return I(null);
        v.then(I.bind(null, null)).catch(I);
      } });
      return x;
      function A(I) {
        I.done ? x.push(null) : x.push(I.value);
      }
    }
    static from(r, w) {
      if (ft(v = r) && v.readable) return r;
      var v;
      if (r[xt]) return this._fromAsyncIterator(r[xt](), w);
      Array.isArray(r) || (r = r === void 0 ? [] : [r]);
      let x = 0;
      return new pt({ ...w, read(A) {
        this.push(x === r.length ? null : r[x++]), A(null);
      } });
    }
    static isBackpressured(r) {
      return !!(17422 & r._duplexState) || r._readableState.buffered >= r._readableState.highWaterMark;
    }
    static isPaused(r) {
      return (r._duplexState & C) === 0;
    }
    [xt]() {
      const r = this;
      let w = null, v = null, x = null;
      return this.on("error", (q) => {
        w = q;
      }), this.on("readable", function() {
        v !== null && A(r.read());
      }), this.on("close", function() {
        v !== null && A(null);
      }), { [xt]() {
        return this;
      }, next: () => new Promise(function(q, nt) {
        v = q, x = nt;
        const E = r.read();
        E !== null ? A(E) : 8 & r._duplexState && A(null);
      }), return: () => I(null), throw: (q) => I(q) };
      function A(q) {
        x !== null && (w ? x(w) : q === null && (r._duplexState & d) === 0 ? x(t) : v({ value: q, done: q === null }), x = v = null);
      }
      function I(q) {
        return r.destroy(q), new Promise((nt, E) => {
          if (8 & r._duplexState) return nt({ value: void 0, done: !0 });
          r.once("close", function() {
            q ? E(q) : nt({ value: void 0, done: !0 });
          });
        });
      }
    }
  }
  class Yt extends Gt {
    constructor(r) {
      super(r), this._duplexState |= 16385, this._writableState = new Ae(this, r), r && (r.writev && (this._writev = r.writev), r.write && (this._write = r.write), r.final && (this._final = r.final), r.eagerOpen && this._writableState.updateNextTick());
    }
    cork() {
      this._duplexState |= we;
    }
    uncork() {
      this._duplexState &= Ce, this._writableState.updateNextTick();
    }
    _writev(r, w) {
      w(null);
    }
    _write(r, w) {
      this._writableState.autoBatch(r, w);
    }
    _final(r) {
      r(null);
    }
    static isBackpressured(r) {
      return !!(146800654 & r._duplexState);
    }
    static drained(r) {
      if (r.destroyed) return Promise.resolve(!1);
      const w = r._writableState;
      var v;
      const x = ((v = r)._writev !== Yt.prototype._writev && v._writev !== Jt.prototype._writev ? Math.min(1, w.queue.length) : w.queue.length) + (r._duplexState & $n ? 1 : 0);
      return x === 0 ? Promise.resolve(!0) : (w.drains === null && (w.drains = []), new Promise((A) => {
        w.drains.push({ writes: x, resolve: A });
      }));
    }
    write(r) {
      return this._writableState.updateNextTick(), this._writableState.push(r);
    }
    end(r) {
      return this._writableState.updateNextTick(), this._writableState.end(r), this;
    }
  }
  class Jt extends pt {
    constructor(r) {
      super(r), this._duplexState = 1 | this._duplexState & _, this._writableState = new Ae(this, r), r && (r.writev && (this._writev = r.writev), r.write && (this._write = r.write), r.final && (this._final = r.final));
    }
    cork() {
      this._duplexState |= we;
    }
    uncork() {
      this._duplexState &= Ce, this._writableState.updateNextTick();
    }
    _writev(r, w) {
      w(null);
    }
    _write(r, w) {
      this._writableState.autoBatch(r, w);
    }
    _final(r) {
      r(null);
    }
    write(r) {
      return this._writableState.updateNextTick(), this._writableState.push(r);
    }
    end(r) {
      return this._writableState.updateNextTick(), this._writableState.end(r), this;
    }
  }
  class Ee extends Jt {
    constructor(r) {
      super(r), this._transformState = new Yn(this), r && (r.transform && (this._transform = r.transform), r.flush && (this._flush = r.flush));
    }
    _write(r, w) {
      this._readableState.buffered >= this._readableState.highWaterMark ? this._transformState.data = r : this._transform(r, this._transformState.afterTransform);
    }
    _read(r) {
      if (this._transformState.data !== null) {
        const w = this._transformState.data;
        this._transformState.data = null, r(null), this._transform(w, this._transformState.afterTransform);
      } else r(null);
    }
    destroy(r) {
      super.destroy(r), this._transformState.data !== null && (this._transformState.data = null, this._transformState.afterTransform());
    }
    _transform(r, w) {
      w(null, r);
    }
    _flush(r) {
      r(null);
    }
    _final(r) {
      this._transformState.afterFinal = r, this._flush(is.bind(this));
    }
  }
  function is(b, r) {
    const w = this._transformState.afterFinal;
    if (b) return w(b);
    r != null && this.push(r), this.push(null), w(null);
  }
  function Re(b, ...r) {
    const w = Array.isArray(b) ? [...b, ...r] : [b, ...r], v = w.length && typeof w[w.length - 1] == "function" ? w.pop() : null;
    if (w.length < 2) throw new Error("Pipeline requires at least 2 streams");
    let x = w[0], A = null, I = null;
    for (let E = 1; E < w.length; E++) A = w[E], ft(x) ? x.pipe(A, nt) : (q(x, !0, E > 1, nt), x.pipe(A)), x = A;
    if (v) {
      let E = !1;
      const _t = ft(A) || !(!A._writableState || !A._writableState.autoDestroy);
      A.on("error", (Vt) => {
        I === null && (I = Vt);
      }), A.on("finish", () => {
        E = !0, _t || v(I);
      }), _t && A.on("close", () => v(I || (E ? null : e)));
    }
    return A;
    function q(E, _t, Vt, Kt) {
      E.on("error", Kt), E.on("close", function() {
        if (E._readableState && !E._readableState.ended || Vt && E._writableState && !E._writableState.ended) return Kt(e);
      });
    }
    function nt(E) {
      if (E && !I) {
        I = E;
        for (const _t of w) _t.destroy(E);
      }
    }
  }
  function rs(b) {
    return b;
  }
  function Pe(b) {
    return !!b._readableState || !!b._writableState;
  }
  function ft(b) {
    return typeof b._duplexState == "number" && Pe(b);
  }
  function Be(b) {
    return (function(r) {
      return typeof r == "object" && r !== null && typeof r.byteLength == "number";
    })(b) ? b.byteLength : 1024;
  }
  function qe() {
  }
  function os() {
    this.destroy(new Error("Stream aborted."));
  }
  return on = { pipeline: Re, pipelinePromise: function(...b) {
    return new Promise((r, w) => Re(...b, (v) => {
      if (v) return w(v);
      r();
    }));
  }, isStream: Pe, isStreamx: ft, isEnded: function(b) {
    return !!b._readableState && b._readableState.ended;
  }, isFinished: function(b) {
    return !!b._writableState && b._writableState.ended;
  }, isDisturbed: function(b) {
    return !!(1 & ~b._duplexState) || (b._duplexState & zt) !== 0;
  }, getStreamError: function(b, r = {}) {
    const w = b._readableState && b._readableState.error || b._writableState && b._writableState.error;
    return r.all || w !== t ? w : null;
  }, Stream: Gt, Writable: Yt, Readable: pt, Duplex: Jt, Transform: Ee, PassThrough: class extends Ee {
  } };
})();
const R = it((function() {
  if (cn) return dn;
  function i(t, e) {
    for (const n in e) Object.defineProperty(t, n, { value: e[n], enumerable: !0, configurable: !0 });
    return t;
  }
  return cn = 1, dn = function(t, e, n) {
    if (!t || typeof t == "string") throw new TypeError("Please pass an Error to err-code");
    n || (n = {}), typeof e == "object" && (n = e, e = ""), e && (n.code = e);
    try {
      return i(t, n);
    } catch {
      n.message = t.message, n.stack = t.stack;
      const o = function() {
      };
      return o.prototype = Object.create(Object.getPrototypeOf(t)), i(new o(), n);
    }
  };
})()), Mt = "0123456789abcdef", Pn = [], Ft = [];
for (let i = 0; i < 256; i++) Pn[i] = Mt[i >> 4 & 15] + Mt[15 & i], i < 16 && (i < 10 ? Ft[48 + i] = i : Ft[87 + i] = i);
const lt = (i) => {
  const t = i.length;
  let e = "", n = 0;
  for (; n < t; ) e += Pn[i[n++]];
  return e;
}, de = (i) => {
  const t = i.length >> 1, e = t << 1, n = new Uint8Array(t);
  let s = 0, o = 0;
  for (; o < e; ) n[s++] = Ft[i.charCodeAt(o++)] << 4 | Ft[i.charCodeAt(o++)];
  return n;
};
for (var ws = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bs = typeof Uint8Array > "u" ? [] : new Uint8Array(256), It = 0; It < 64; It++) bs[ws.charCodeAt(It)] = It;
const Cs = new TextDecoder(), Bn = (i, t) => Cs.decode(i), vs = new TextEncoder(), ye = (i) => vs.encode(i), at = (i) => {
  let t, e = "", n = 0;
  const s = i.length;
  for (; n < s; ) t = i.charCodeAt(n++), e += Mt[t >> 4] + Mt[15 & t];
  return e;
}, bt = (i) => {
  const t = de(i);
  if (t.length <= 65536) return String.fromCharCode(...t);
  let e = "", n = 0;
  for (; n < t.length; ) e += String.fromCharCode(...t.subarray(n, n += 65536));
  return e;
}, ln = typeof window < "u" ? window : self, ce = ln.crypto || ln.msCrypto || {};
ce.subtle || ce.webkitSubtle;
const Ut = (i) => {
  const t = new Uint8Array(i);
  return ce.getRandomValues(t);
}, ks = U("simple-peer"), te = 65536;
function un(i) {
  return i.replace(/a=ice-options:trickle\s\n/g, "");
}
let Ct = class le extends Rn.Duplex {
  _pc;
  constructor(t) {
    if (super(t = Object.assign({ allowHalfOpen: !1 }, t)), this.__objectMode = !!t.objectMode, this._id = lt(Ut(4)).slice(0, 7), this._debug("new peer %o", t), this.channelName = t.initiator ? t.channelName || lt(Ut(20)) : null, this.initiator = t.initiator || !1, this.channelConfig = t.channelConfig || le.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, le.config, t.config), this.offerOptions = t.offerOptions || {}, this.answerOptions = t.answerOptions || {}, this.sdpTransform = t.sdpTransform || ((e) => e), this.trickle = t.trickle === void 0 || t.trickle, this.allowHalfTrickle = t.allowHalfTrickle !== void 0 && t.allowHalfTrickle, this.iceCompleteTimeout = t.iceCompleteTimeout || 5e3, this._destroying = !1, this._connected = !1, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, !he) throw R(typeof window > "u" ? new Error("No WebRTC support: Specify `opts.wrtc` option in this environment") : new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
    this._pcReady = !1, this._channelReady = !1, this._iceComplete = !1, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = !1, this._firstNegotiation = !0, this._batchedNegotiation = !1, this._queuedNegotiation = !1, this._sendersAwaitingStable = [], this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
    try {
      this._pc = new he(this.config);
    } catch (e) {
      return void this.__destroy(R(e, "ERR_PC_CONSTRUCTOR"));
    }
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId == "number", this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange();
    }, this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange();
    }, this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange();
    }, this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange();
    }, this._pc.onicecandidate = (e) => {
      this._onIceCandidate(e);
    }, typeof this._pc.peerIdentity == "object" && this._pc.peerIdentity.catch((e) => {
      this.__destroy(R(e, "ERR_PC_PEER_IDENTITY"));
    }), this.initiator || this.channelNegotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = (e) => {
      this._setupData(e);
    }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
      this._onFinish();
    }, this.once("finish", this._onFinishBound);
  }
  get bufferSize() {
    return this._channel && this._channel.bufferedAmount || 0;
  }
  get connected() {
    return this._connected && this._channel.readyState === "open";
  }
  address() {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress };
  }
  signal(t) {
    if (!this._destroying) {
      if (this.destroyed) throw R(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
      if (typeof t == "string") try {
        t = JSON.parse(t);
      } catch {
        t = {};
      }
      this._debug("signal()"), t.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), t.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(t.transceiverRequest.kind, t.transceiverRequest.init)), t.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(t.candidate) : this._pendingCandidates.push(t.candidate)), t.sdp && this._pc.setRemoteDescription(new fs(t)).then(() => {
        this.destroyed || (this._pendingCandidates.forEach((e) => {
          this._addIceCandidate(e);
        }), this._pendingCandidates = [], this._pc.remoteDescription.type === "offer" && this._createAnswer());
      }).catch((e) => {
        this.__destroy(R(e, "ERR_SET_REMOTE_DESCRIPTION"));
      }), t.sdp || t.candidate || t.renegotiate || t.transceiverRequest || this.__destroy(R(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
    }
  }
  _addIceCandidate(t) {
    const e = new _s(t);
    this._pc.addIceCandidate(e).catch((n) => {
      var s;
      !e.address || e.address.endsWith(".local") ? (s = "Ignoring unsupported ICE candidate.", console.warn(s)) : this.__destroy(R(n, "ERR_ADD_ICE_CANDIDATE"));
    });
  }
  send(t) {
    if (!this._destroying) {
      if (this.destroyed) throw R(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
      this._channel.send(t);
    }
  }
  _needsNegotiation() {
    this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = !0, queueMicrotask(() => {
      this._batchedNegotiation = !1, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = !1;
    }));
  }
  negotiate() {
    if (!this._destroying) {
      if (this.destroyed) throw R(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
      this.initiator ? this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
        this._createOffer();
      }, 0)) : this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { type: "renegotiate", renegotiate: !0 })), this._isNegotiating = !0;
    }
  }
  _final(t) {
    this._readableState.ended || this.push(null), t(null);
  }
  __destroy(t) {
    this.end(), this._destroy(() => {
    }, t);
  }
  _destroy(t, e) {
    this.destroyed || this._destroying || (this._destroying = !0, this._debug("destroying (error: %s)", e && (e.message || e)), setTimeout(() => {
      if (this._connected && this.emit("disconnect"), this._connected = !1, this._pcReady = !1, this._channelReady = !1, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
        try {
          this._channel.close();
        } catch {
        }
        this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
      }
      if (this._pc) {
        try {
          this._pc.close();
        } catch {
        }
        this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
      }
      this._pc = null, this._channel = null, e && this.emit("error", e), t();
    }, 0));
  }
  _setupData(t) {
    if (!t.channel) return this.__destroy(R(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
    this._channel = t.channel, this._channel.binaryType = "arraybuffer", typeof this._channel.bufferedAmountLowThreshold == "number" && (this._channel.bufferedAmountLowThreshold = te), this.channelName = this._channel.label, this._channel.onmessage = (n) => {
      this._onChannelMessage(n);
    }, this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow();
    }, this._channel.onopen = () => {
      this._onChannelOpen();
    }, this._channel.onclose = () => {
      this._onChannelClose();
    }, this._channel.onerror = (n) => {
      const s = n.error instanceof Error ? n.error : new Error(`Datachannel error: ${n.message} ${n.filename}:${n.lineno}:${n.colno}`);
      this.__destroy(R(s, "ERR_DATA_CHANNEL"));
    };
    let e = !1;
    this._closingInterval = setInterval(() => {
      this._channel && this._channel.readyState === "closing" ? (e && this._onChannelClose(), e = !0) : e = !1;
    }, 5e3);
  }
  _write(t, e) {
    if (this.destroyed) return e(R(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
    if (this._connected) {
      try {
        this.send(t);
      } catch (n) {
        return this.__destroy(R(n, "ERR_DATA_CHANNEL"));
      }
      this._channel.bufferedAmount > te ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = e) : e(null);
    } else this._debug("write before connect"), this._chunk = t, this._cb = e;
  }
  _onFinish() {
    if (this.destroyed) return;
    const t = () => {
      setTimeout(() => this.__destroy(), 1e3);
    };
    this._connected ? t() : this.once("connect", t);
  }
  _startIceCompleteTimeout() {
    this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
      this._iceComplete || (this._iceComplete = !0, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
    }, this.iceCompleteTimeout));
  }
  _createOffer() {
    this.destroyed || this._pc.createOffer(this.offerOptions).then((t) => {
      if (this.destroyed) return;
      this.trickle || this.allowHalfTrickle || (t.sdp = un(t.sdp)), t.sdp = this.sdpTransform(t.sdp);
      const e = () => {
        if (this.destroyed) return;
        const n = this._pc.localDescription || t;
        this._debug("signal"), this.emit("signal", { type: n.type, sdp: n.sdp });
      };
      this._pc.setLocalDescription(t).then(() => {
        this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? e() : this.once("_iceComplete", e));
      }).catch((n) => {
        this.__destroy(R(n, "ERR_SET_LOCAL_DESCRIPTION"));
      });
    }).catch((t) => {
      this.__destroy(R(t, "ERR_CREATE_OFFER"));
    });
  }
  _createAnswer() {
    this.destroyed || this._pc.createAnswer(this.answerOptions).then((t) => {
      if (this.destroyed) return;
      this.trickle || this.allowHalfTrickle || (t.sdp = un(t.sdp)), t.sdp = this.sdpTransform(t.sdp);
      const e = () => {
        if (this.destroyed) return;
        const n = this._pc.localDescription || t;
        this._debug("signal"), this.emit("signal", { type: n.type, sdp: n.sdp }), this.initiator || this._requestMissingTransceivers?.();
      };
      this._pc.setLocalDescription(t).then(() => {
        this.destroyed || (this.trickle || this._iceComplete ? e() : this.once("_iceComplete", e));
      }).catch((n) => {
        this.__destroy(R(n, "ERR_SET_LOCAL_DESCRIPTION"));
      });
    }).catch((t) => {
      this.__destroy(R(t, "ERR_CREATE_ANSWER"));
    });
  }
  _onConnectionStateChange() {
    this.destroyed || this._destroying || this._pc.connectionState === "failed" && this.__destroy(R(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
  }
  _onIceStateChange() {
    if (this.destroyed) return;
    const t = this._pc.iceConnectionState, e = this._pc.iceGatheringState;
    this._debug("iceStateChange (connection: %s) (gathering: %s)", t, e), this.emit("iceStateChange", t, e), t !== "connected" && t !== "completed" || (this._pcReady = !0, this._maybeReady()), t === "failed" && this.__destroy(R(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), t === "closed" && this.__destroy(R(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
  }
  getStats(t) {
    const e = (n) => (Object.prototype.toString.call(n.values) === "[object Array]" && n.values.forEach((s) => {
      Object.assign(n, s);
    }), n);
    this._pc.getStats.length === 0 || this._isReactNativeWebrtc ? this._pc.getStats().then((n) => {
      const s = [];
      n.forEach((o) => {
        s.push(e(o));
      }), t(null, s);
    }, (n) => t(n)) : this._pc.getStats.length > 0 ? this._pc.getStats((n) => {
      if (this.destroyed) return;
      const s = [];
      n.result().forEach((o) => {
        const a = {};
        o.names().forEach((h) => {
          a[h] = o.stat(h);
        }), a.id = o.id, a.type = o.type, a.timestamp = o.timestamp, s.push(e(a));
      }), t(null, s);
    }, (n) => t(n)) : t(null, []);
  }
  _maybeReady() {
    if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
    this._connecting = !0;
    const t = () => {
      this.destroyed || this._destroying || this.getStats((e, n) => {
        if (this.destroyed || this._destroying) return;
        e && (n = []);
        const s = {}, o = {}, a = {};
        let h = !1;
        n.forEach((c) => {
          c.type !== "remotecandidate" && c.type !== "remote-candidate" || (s[c.id] = c), c.type !== "localcandidate" && c.type !== "local-candidate" || (o[c.id] = c), c.type !== "candidatepair" && c.type !== "candidate-pair" || (a[c.id] = c);
        });
        const l = (c) => {
          h = !0;
          let f = o[c.localCandidateId];
          f && (f.ip || f.address) ? (this.localAddress = f.ip || f.address, this.localPort = Number(f.port)) : f && f.ipAddress ? (this.localAddress = f.ipAddress, this.localPort = Number(f.portNumber)) : typeof c.googLocalAddress == "string" && (f = c.googLocalAddress.split(":"), this.localAddress = f[0], this.localPort = Number(f[1])), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
          let S = s[c.remoteCandidateId];
          S && (S.ip || S.address) ? (this.remoteAddress = S.ip || S.address, this.remotePort = Number(S.port)) : S && S.ipAddress ? (this.remoteAddress = S.ipAddress, this.remotePort = Number(S.portNumber)) : typeof c.googRemoteAddress == "string" && (S = c.googRemoteAddress.split(":"), this.remoteAddress = S[0], this.remotePort = Number(S[1])), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
        };
        if (n.forEach((c) => {
          c.type === "transport" && c.selectedCandidatePairId && l(a[c.selectedCandidatePairId]), (c.type === "googCandidatePair" && c.googActiveConnection === "true" || (c.type === "candidatepair" || c.type === "candidate-pair") && c.selected) && l(c);
        }), h || Object.keys(a).length && !Object.keys(o).length) {
          if (this._connecting = !1, this._connected = !0, this.emit("connect"), this._chunk) {
            try {
              this.send(this._chunk);
            } catch (f) {
              return this.__destroy(R(f, "ERR_DATA_CHANNEL"));
            }
            this._chunk = null, this._debug('sent chunk from "write before connect"');
            const c = this._cb;
            this._cb = null, c(null);
          }
          typeof this._channel.bufferedAmountLowThreshold != "number" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
        } else setTimeout(t, 100);
      });
    };
    t();
  }
  _onInterval() {
    !this._cb || !this._channel || this._channel.bufferedAmount > te || this._onChannelBufferedAmountLow();
  }
  _onSignalingStateChange() {
    this.destroyed || (this._pc.signalingState === "stable" && (this._isNegotiating = !1, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((t) => {
      this._pc.removeTrack(t), this._queuedNegotiation = !0;
    }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = !1, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
  }
  _onIceCandidate(t) {
    this.destroyed || (t.candidate && this.trickle ? this.emit("signal", { type: "candidate", candidate: { candidate: t.candidate.candidate, sdpMLineIndex: t.candidate.sdpMLineIndex, sdpMid: t.candidate.sdpMid } }) : t.candidate || this._iceComplete || (this._iceComplete = !0, this.emit("_iceComplete")), t.candidate && this._startIceCompleteTimeout());
  }
  _onChannelMessage(t) {
    if (this.destroyed) return;
    let e = t.data;
    e instanceof ArrayBuffer ? e = new Uint8Array(e) : this.__objectMode === !1 && (e = ye(e)), this.push(e);
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb) return;
    this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
    const t = this._cb;
    this._cb = null, t(null);
  }
  _onChannelOpen() {
    this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = !0, this._maybeReady());
  }
  _onChannelClose() {
    this.destroyed || (this._debug("on channel close"), this.__destroy());
  }
  _debug() {
    const t = [].slice.call(arguments);
    t[0] = "[" + this._id + "] " + t[0], ks.apply(null, t);
  }
};
Ct.WEBRTC_SUPPORT = !!he, Ct.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, Ct.channelConfig = {};
const ue = it(En()), F = {}, ge = { DEFAULT_ANNOUNCE_PEERS: 50, MAX_ANNOUNCE_PEERS: 82, parseUrl: (i) => {
  const t = new URL(i.replace(/^udp:/, "http:"));
  return i.match(/^udp:/) && Object.defineProperties(t, { href: { value: t.href.replace(/^http/, "udp") }, protocol: { value: t.protocol.replace(/^http/, "udp") }, origin: { value: t.origin.replace(/^http/, "udp") } }), t;
}, ...Object.freeze(Object.defineProperty({ __proto__: null, default: F }, Symbol.toStringTag, { value: "Module" })) }, Ts = U("simple-websocket"), St = typeof F != "function" ? WebSocket : F;
class qn extends Rn.Duplex {
  constructor(t = {}) {
    if (typeof t == "string" && (t = { url: t }), super(t = Object.assign({ allowHalfOpen: !1 }, t)), this.__objectMode = !!t.objectMode, t.objectMode != null && delete t.objectMode, t.url == null && t.socket == null) throw new Error("Missing required `url` or `socket` option");
    if (t.url != null && t.socket != null) throw new Error("Must specify either `url` or `socket` option, not both");
    if (this._id = lt(Ut(4)).slice(0, 7), this._debug("new websocket: %o", t), this.connected = !1, this._chunk = null, this._cb = null, this._interval = null, t.socket) this.url = t.socket.url, this._ws = t.socket, this.connected = t.socket.readyState === St.OPEN;
    else {
      this.url = t.url;
      try {
        this._ws = typeof F == "function" ? new St(t.url, { ...t, encoding: void 0 }) : new St(t.url);
      } catch (e) {
        return void ue(() => this.destroy(e));
      }
    }
    this._ws.binaryType = "arraybuffer", t.socket && this.connected ? ue(() => this._handleOpen()) : this._ws.onopen = () => this._handleOpen(), this._ws.onmessage = (e) => this._handleMessage(e), this._ws.onclose = () => this._handleClose(), this._ws.onerror = (e) => this._handleError(e), this._handleFinishBound = () => this._handleFinish(), this.once("finish", this._handleFinishBound);
  }
  send(t) {
    this._ws.send(t);
  }
  _final(t) {
    this._readableState.ended || this.push(null), t(null);
  }
  _destroy(t) {
    if (!this.destroyed) {
      if (this._writableState.ended || this.end(), this.connected = !1, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._handleFinishBound && this.removeListener("finish", this._handleFinishBound), this._handleFinishBound = null, this._ws) {
        const e = this._ws, n = () => {
          e.onclose = null;
        };
        if (e.readyState === St.CLOSED) n();
        else try {
          e.onclose = n, e.close();
        } catch {
          n();
        }
        e.onopen = null, e.onmessage = null, e.onerror = () => {
        };
      }
      this._ws = null, t();
    }
  }
  _write(t, e) {
    if (this.destroyed) return e(new Error("cannot write after socket is destroyed"));
    if (this.connected) {
      try {
        this.send(t);
      } catch (n) {
        return this.destroy(n);
      }
      typeof F != "function" && this._ws.bufferedAmount > 65536 ? (this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount), this._cb = e) : e(null);
    } else this._debug("write before connect"), this._chunk = t, this._cb = e;
  }
  _handleOpen() {
    if (!this.connected && !this.destroyed) {
      if (this.connected = !0, this._chunk) {
        try {
          this.send(this._chunk);
        } catch (e) {
          return this.destroy(e);
        }
        this._chunk = null, this._debug('sent chunk from "write before connect"');
        const t = this._cb;
        this._cb = null, t(null);
      }
      typeof F != "function" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
    }
  }
  _handleMessage(t) {
    if (this.destroyed) return;
    let e = t.data;
    e instanceof ArrayBuffer && (e = new Uint8Array(e)), this.__objectMode === !1 && (e = ye(e)), this.push(e);
  }
  _handleClose() {
    this.destroyed || (this._debug("on close"), this.destroy());
  }
  _handleError(t) {
    this.destroy(new Error(`Error connecting to ${this.url}`));
  }
  _handleFinish() {
    if (this.destroyed) return;
    const t = () => {
      setTimeout(() => this.destroy(), 1e3);
    };
    this.connected ? t() : this.once("connect", t);
  }
  _onInterval() {
    if (!this._cb || !this._ws || this._ws.bufferedAmount > 65536) return;
    this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
    const t = this._cb;
    this._cb = null, t(null);
  }
  _debug() {
    const t = [].slice.call(arguments);
    t[0] = "[" + this._id + "] " + t[0], Ts.apply(null, t);
  }
}
qn.WEBSOCKET_SUPPORT = !!St;
class xs extends In {
  constructor(t, e) {
    super(), this.client = t, this.announceUrl = e, this.interval = null, this.destroyed = !1;
  }
  setInterval(t) {
    t == null && (t = this.DEFAULT_ANNOUNCE_INTERVAL), clearInterval(this.interval), t && (this.interval = setInterval(() => {
      this.announce(this.client._defaultAnnounceOpts());
    }, t), this.interval.unref && this.interval.unref());
  }
}
const N = U("bittorrent-tracker:websocket-tracker"), Q = {};
class me extends xs {
  constructor(t, e) {
    super(t, e), N("new websocket tracker %s", e), this.peers = {}, this.socket = null, this.reconnecting = !1, this.retries = 0, this.reconnectTimer = null, this.expectingResponse = !1, this._openSocket();
  }
  announce(t) {
    if (this.destroyed || this.reconnecting) return;
    if (!this.socket.connected) return void this.socket.once("connect", () => {
      this.announce(t);
    });
    const e = Object.assign({}, t, { action: "announce", info_hash: this.client._infoHashBinary, peer_id: this.client._peerIdBinary });
    if (this._trackerId && (e.trackerid = this._trackerId), t.event === "stopped" || t.event === "completed") this._send(e);
    else {
      const n = Math.min(t.numwant, 5);
      this._generateOffers(n, (s) => {
        e.numwant = n, e.offers = s, this._send(e);
      });
    }
  }
  scrape(t) {
    if (this.destroyed || this.reconnecting) return;
    if (!this.socket.connected) return void this.socket.once("connect", () => {
      this.scrape(t);
    });
    const e = { action: "scrape", info_hash: Array.isArray(t.infoHash) && t.infoHash.length > 0 ? t.infoHash.map((n) => bt(n)) : t.infoHash && bt(t.infoHash) || this.client._infoHashBinary };
    this._send(e);
  }
  destroy(t = gn) {
    if (this.destroyed) return t(null);
    this.destroyed = !0, clearInterval(this.interval), clearTimeout(this.reconnectTimer);
    for (const o in this.peers) {
      const a = this.peers[o];
      clearTimeout(a.trackerTimeout), a.destroy();
    }
    if (this.peers = null, this.socket && (this.socket.removeListener("connect", this._onSocketConnectBound), this.socket.removeListener("data", this._onSocketDataBound), this.socket.removeListener("close", this._onSocketCloseBound), this.socket.removeListener("error", this._onSocketErrorBound), this.socket = null), this._onSocketConnectBound = null, this._onSocketErrorBound = null, this._onSocketDataBound = null, this._onSocketCloseBound = null, Q[this.announceUrl] && (Q[this.announceUrl].consumers -= 1), Q[this.announceUrl].consumers > 0) return t();
    let e, n = Q[this.announceUrl];
    if (delete Q[this.announceUrl], n.on("error", gn), n.once("close", t), !this.expectingResponse) return s();
    function s() {
      e && (clearTimeout(e), e = null), n.removeListener("data", s), n.destroy(), n = null;
    }
    e = setTimeout(s, ge.DESTROY_TIMEOUT), n.once("data", s);
  }
  _openSocket() {
    if (this.destroyed = !1, this.peers || (this.peers = {}), this._onSocketConnectBound = () => {
      this._onSocketConnect();
    }, this._onSocketErrorBound = (t) => {
      this._onSocketError(t);
    }, this._onSocketDataBound = (t) => {
      this._onSocketData(t);
    }, this._onSocketCloseBound = () => {
      this._onSocketClose();
    }, this.socket = Q[this.announceUrl], this.socket) Q[this.announceUrl].consumers += 1, this.socket.connected && this._onSocketConnectBound();
    else {
      const t = new URL(this.announceUrl);
      let e;
      this.client._proxyOpts && (e = t.protocol === "wss:" ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent, !e && this.client._proxyOpts.socksProxy && (e = this.client._proxyOpts.socksProxy)), this.socket = Q[this.announceUrl] = new qn({ url: this.announceUrl, agent: e }), this.socket.consumers = 1, this.socket.once("connect", this._onSocketConnectBound);
    }
    this.socket.on("data", this._onSocketDataBound), this.socket.once("close", this._onSocketCloseBound), this.socket.once("error", this._onSocketErrorBound);
  }
  _onSocketConnect() {
    this.destroyed || this.reconnecting && (this.reconnecting = !1, this.retries = 0, this.announce(this.client._defaultAnnounceOpts()));
  }
  _onSocketData(t) {
    if (!this.destroyed) {
      this.expectingResponse = !1;
      try {
        t = JSON.parse(Bn(t));
      } catch {
        return void this.client.emit("warning", new Error("Invalid tracker response"));
      }
      t.action === "announce" ? this._onAnnounceResponse(t) : t.action === "scrape" ? this._onScrapeResponse(t) : this._onSocketError(new Error(`invalid action in WS response: ${t.action}`));
    }
  }
  _onAnnounceResponse(t) {
    if (t.info_hash !== this.client._infoHashBinary) return void N("ignoring websocket data from %s for %s (looking for %s: reused socket)", this.announceUrl, at(t.info_hash), this.client.infoHash);
    if (t.peer_id && t.peer_id === this.client._peerIdBinary) return;
    N("received %s from %s for %s", JSON.stringify(t), this.announceUrl, this.client.infoHash);
    const e = t["failure reason"];
    if (e) return this.client.emit("warning", new Error(e));
    const n = t["warning message"];
    n && this.client.emit("warning", new Error(n));
    const s = t.interval || t["min interval"];
    s && this.setInterval(1e3 * s);
    const o = t["tracker id"];
    if (o && (this._trackerId = o), t.complete != null) {
      const h = Object.assign({}, t, { announce: this.announceUrl, infoHash: at(t.info_hash) });
      this.client.emit("update", h);
    }
    let a;
    if (t.offer && t.peer_id && (N("creating peer (from remote offer)"), a = this._createPeer(), a.id = at(t.peer_id), a.once("signal", (h) => {
      const l = { action: "announce", info_hash: this.client._infoHashBinary, peer_id: this.client._peerIdBinary, to_peer_id: t.peer_id, answer: h, offer_id: t.offer_id };
      this._trackerId && (l.trackerid = this._trackerId), this._send(l);
    }), this.client.emit("peer", a), a.signal(t.offer)), t.answer && t.peer_id) {
      const h = at(t.offer_id);
      a = this.peers[h], a ? (a.id = at(t.peer_id), this.client.emit("peer", a), a.signal(t.answer), clearTimeout(a.trackerTimeout), a.trackerTimeout = null, delete this.peers[h]) : N(`got unexpected answer: ${JSON.stringify(t.answer)}`);
    }
  }
  _onScrapeResponse(t) {
    t = t.files || {};
    const e = Object.keys(t);
    e.length !== 0 ? e.forEach((n) => {
      const s = Object.assign(t[n], { announce: this.announceUrl, infoHash: at(n) });
      this.client.emit("scrape", s);
    }) : this.client.emit("warning", new Error("invalid scrape response"));
  }
  _onSocketClose() {
    this.destroyed || (this.destroy(), this._startReconnectTimer());
  }
  _onSocketError(t) {
    this.destroyed || (this.destroy(), this.client.emit("warning", t), this._startReconnectTimer());
  }
  _startReconnectTimer() {
    const t = Math.floor(3e5 * Math.random()) + Math.min(1e4 * Math.pow(2, this.retries), 36e5);
    this.reconnecting = !0, clearTimeout(this.reconnectTimer), this.reconnectTimer = setTimeout(() => {
      this.retries++, this._openSocket();
    }, t), this.reconnectTimer.unref && this.reconnectTimer.unref(), N("reconnecting socket in %s ms", t);
  }
  _send(t) {
    if (this.destroyed) return;
    this.expectingResponse = !0;
    const e = JSON.stringify(t);
    N("send %s", e), this.socket.send(e);
  }
  _generateOffers(t, e) {
    const n = this, s = [];
    N("generating %s offers", t);
    for (let h = 0; h < t; ++h) o();
    function o() {
      const h = lt(Ut(20));
      N("creating peer (from _generateOffers)");
      const l = n.peers[h] = n._createPeer({ initiator: !0 });
      l.once("signal", (c) => {
        s.push({ offer: c, offer_id: bt(h) }), a();
      }), l.trackerTimeout = setTimeout(() => {
        N("tracker timeout: destroying peer"), l.trackerTimeout = null, delete n.peers[h], l.destroy();
      }, 5e4), l.trackerTimeout.unref && l.trackerTimeout.unref();
    }
    function a() {
      s.length === t && (N("generated %s offers", t), e(s));
    }
    a();
  }
  _createPeer(t) {
    const e = this;
    t = Object.assign({ trickle: !1, config: e.client._rtcConfig, wrtc: e.client._wrtc }, t);
    const n = new Ct(t);
    return n.once("error", s), n.once("connect", function o() {
      n.removeListener("error", s), n.removeListener("connect", o);
    }), n;
    function s(o) {
      e.client.emit("warning", new Error(`Connection error: ${o.message}`)), n.destroy();
    }
  }
}
function gn() {
}
me.prototype.DEFAULT_ANNOUNCE_INTERVAL = 3e4, me._socketPool = Q;
const Z = U("bittorrent-tracker:client");
class pe extends In {
  constructor(t = {}) {
    if (super(), !t.peerId) throw new Error("Option `peerId` is required");
    if (!t.infoHash) throw new Error("Option `infoHash` is required");
    if (!t.announce) throw new Error("Option `announce` is required");
    if (!Dt.browser && !t.port) throw new Error("Option `port` is required");
    this.peerId = typeof t.peerId == "string" ? t.peerId : lt(t.peerId), this._peerIdBuffer = de(this.peerId), this._peerIdBinary = bt(this.peerId), this.infoHash = typeof t.infoHash == "string" ? t.infoHash.toLowerCase() : lt(t.infoHash), this._infoHashBuffer = de(this.infoHash), this._infoHashBinary = bt(this.infoHash), Z("new client %s", this.infoHash), this.destroyed = !1, this._port = t.port, this._getAnnounceOpts = t.getAnnounceOpts, this._rtcConfig = t.rtcConfig, this._userAgent = t.userAgent, this._proxyOpts = t.proxyOpts, this._wrtc = typeof t.wrtc == "function" ? t.wrtc() : t.wrtc;
    let e = typeof t.announce == "string" ? [t.announce] : t.announce == null ? [] : t.announce;
    e = e.map((o) => (ArrayBuffer.isView(o) && (o = Bn(o)), o[o.length - 1] === "/" && (o = o.substring(0, o.length - 1)), o)), e = Array.from(new Set(e));
    const n = this._wrtc !== !1 && (!!this._wrtc || Ct.WEBRTC_SUPPORT), s = (o) => {
      ue(() => {
        this.emit("warning", o);
      });
    };
    this._trackers = e.map((o) => {
      let a;
      try {
        a = ge.parseUrl(o);
      } catch {
        return s(new Error(`Invalid tracker URL: ${o}`)), null;
      }
      const h = a.port;
      if (h < 0 || h > 65535) return s(new Error(`Invalid tracker port: ${o}`)), null;
      const l = a.protocol;
      return l !== "http:" && l !== "https:" || typeof F != "function" ? l === "udp:" && typeof F == "function" ? new F(this, o) : l !== "ws:" && l !== "wss:" || !n || l === "ws:" && typeof window < "u" && window.location.protocol === "https:" ? (s(new Error(`Unsupported tracker protocol: ${o}`)), null) : new me(this, o) : new F(this, o);
    }).filter(Boolean);
  }
  start(t) {
    (t = this._defaultAnnounceOpts(t)).event = "started", Z("send `start` %o", t), this._announce(t), this._trackers.forEach((e) => {
      e.setInterval();
    });
  }
  stop(t) {
    (t = this._defaultAnnounceOpts(t)).event = "stopped", Z("send `stop` %o", t), this._announce(t);
  }
  complete(t) {
    t || (t = {}), (t = this._defaultAnnounceOpts(t)).event = "completed", Z("send `complete` %o", t), this._announce(t);
  }
  update(t) {
    (t = this._defaultAnnounceOpts(t)).event && delete t.event, Z("send `update` %o", t), this._announce(t);
  }
  _announce(t) {
    this._trackers.forEach((e) => {
      e.announce(t);
    });
  }
  scrape(t) {
    Z("send `scrape`"), t || (t = {}), this._trackers.forEach((e) => {
      e.scrape(t);
    });
  }
  setInterval(t) {
    Z("setInterval %d", t), this._trackers.forEach((e) => {
      e.setInterval(t);
    });
  }
  destroy(t) {
    if (this.destroyed) return;
    this.destroyed = !0, Z("destroy");
    const e = this._trackers.map((n) => (s) => {
      n.destroy(s);
    });
    ps(e, t), this._trackers = [], this._getAnnounceOpts = null;
  }
  _defaultAnnounceOpts(t = {}) {
    return t.numwant == null && (t.numwant = ge.DEFAULT_ANNOUNCE_PEERS), t.uploaded == null && (t.uploaded = 0), t.downloaded == null && (t.downloaded = 0), this._getAnnounceOpts && (t = Object.assign({}, t, this._getAnnounceOpts())), t;
  }
}
pe.scrape = (i, t) => {
  if (t = gs(t), !i.infoHash) throw new Error("Option `infoHash` is required");
  if (!i.announce) throw new Error("Option `announce` is required");
  const e = Object.assign({}, i, { infoHash: Array.isArray(i.infoHash) ? i.infoHash[0] : i.infoHash, peerId: ye("01234567890123456789"), port: 6881 }), n = new pe(e);
  n.once("error", t), n.once("warning", t);
  let s = Array.isArray(i.infoHash) ? i.infoHash.length : 1;
  const o = {};
  return n.on("scrape", (a) => {
    if (s -= 1, o[a.infoHash] = a, s === 0) {
      n.destroy();
      const h = Object.keys(o);
      h.length === 1 ? t(null, o[h[0]]) : t(null, o);
    }
  }), n.scrape({ infoHash: i.infoHash }), n;
};
var mn, ee = { exports: {} }, As = (function() {
  if (mn) return ee.exports;
  function i(m, u, d, g, _, p, y) {
    var T = m + (u & d | ~u & g) + (_ >>> 0) + y;
    return (T << p | T >>> 32 - p) + u;
  }
  function t(m, u, d, g, _, p, y) {
    var T = m + (u & g | d & ~g) + (_ >>> 0) + y;
    return (T << p | T >>> 32 - p) + u;
  }
  function e(m, u, d, g, _, p, y) {
    var T = m + (u ^ d ^ g) + (_ >>> 0) + y;
    return (T << p | T >>> 32 - p) + u;
  }
  function n(m, u, d, g, _, p, y) {
    var T = m + (d ^ (u | ~g)) + (_ >>> 0) + y;
    return (T << p | T >>> 32 - p) + u;
  }
  function s(m) {
    return (256 + (255 & m)).toString(16).substr(-2);
  }
  function o(m) {
    return String.fromCharCode(255 & m);
  }
  function a(m) {
    return o(m) + o(m >>> 8) + o(m >>> 16) + o(m >>> 24);
  }
  mn = 1;
  var h = function(m) {
    return unescape(encodeURIComponent(m));
  }, l = ee.exports = function(m) {
    return f(m).toHex();
  }, c = l.fromBytes = function(m) {
    for (var u = (function($) {
      for (var M = $.length, ot = M << 3, K = new Uint32Array(M + 72 >>> 6 << 4), j = 0, gt = $.length; j < gt; ++j) K[j >>> 2] |= $.charCodeAt(j) << ((3 & j) << 3);
      return K[M >> 2] |= 128 << (31 & ot), K[K.length - 2] = ot, K;
    })(m), d = 1732584193, g = 4023233417, _ = 2562383102, p = 271733878, y = 0, T = u.length; y < T; y += 16) {
      var B = d, rt = g, kt = _, Qt = p;
      d = i(d, g, _, p, u[y + 0], 7, 3614090360), p = i(p, d, g, _, u[y + 1], 12, 3905402710), _ = i(_, p, d, g, u[y + 2], 17, 606105819), g = i(g, _, p, d, u[y + 3], 22, 3250441966), d = i(d, g, _, p, u[y + 4], 7, 4118548399), p = i(p, d, g, _, u[y + 5], 12, 1200080426), _ = i(_, p, d, g, u[y + 6], 17, 2821735955), g = i(g, _, p, d, u[y + 7], 22, 4249261313), d = i(d, g, _, p, u[y + 8], 7, 1770035416), p = i(p, d, g, _, u[y + 9], 12, 2336552879), _ = i(_, p, d, g, u[y + 10], 17, 4294925233), g = i(g, _, p, d, u[y + 11], 22, 2304563134), d = i(d, g, _, p, u[y + 12], 7, 1804603682), p = i(p, d, g, _, u[y + 13], 12, 4254626195), _ = i(_, p, d, g, u[y + 14], 17, 2792965006), d = t(d, g = i(g, _, p, d, u[y + 15], 22, 1236535329), _, p, u[y + 1], 5, 4129170786), p = t(p, d, g, _, u[y + 6], 9, 3225465664), _ = t(_, p, d, g, u[y + 11], 14, 643717713), g = t(g, _, p, d, u[y + 0], 20, 3921069994), d = t(d, g, _, p, u[y + 5], 5, 3593408605), p = t(p, d, g, _, u[y + 10], 9, 38016083), _ = t(_, p, d, g, u[y + 15], 14, 3634488961), g = t(g, _, p, d, u[y + 4], 20, 3889429448), d = t(d, g, _, p, u[y + 9], 5, 568446438), p = t(p, d, g, _, u[y + 14], 9, 3275163606), _ = t(_, p, d, g, u[y + 3], 14, 4107603335), g = t(g, _, p, d, u[y + 8], 20, 1163531501), d = t(d, g, _, p, u[y + 13], 5, 2850285829), p = t(p, d, g, _, u[y + 2], 9, 4243563512), _ = t(_, p, d, g, u[y + 7], 14, 1735328473), d = e(d, g = t(g, _, p, d, u[y + 12], 20, 2368359562), _, p, u[y + 5], 4, 4294588738), p = e(p, d, g, _, u[y + 8], 11, 2272392833), _ = e(_, p, d, g, u[y + 11], 16, 1839030562), g = e(g, _, p, d, u[y + 14], 23, 4259657740), d = e(d, g, _, p, u[y + 1], 4, 2763975236), p = e(p, d, g, _, u[y + 4], 11, 1272893353), _ = e(_, p, d, g, u[y + 7], 16, 4139469664), g = e(g, _, p, d, u[y + 10], 23, 3200236656), d = e(d, g, _, p, u[y + 13], 4, 681279174), p = e(p, d, g, _, u[y + 0], 11, 3936430074), _ = e(_, p, d, g, u[y + 3], 16, 3572445317), g = e(g, _, p, d, u[y + 6], 23, 76029189), d = e(d, g, _, p, u[y + 9], 4, 3654602809), p = e(p, d, g, _, u[y + 12], 11, 3873151461), _ = e(_, p, d, g, u[y + 15], 16, 530742520), d = n(d, g = e(g, _, p, d, u[y + 2], 23, 3299628645), _, p, u[y + 0], 6, 4096336452), p = n(p, d, g, _, u[y + 7], 10, 1126891415), _ = n(_, p, d, g, u[y + 14], 15, 2878612391), g = n(g, _, p, d, u[y + 5], 21, 4237533241), d = n(d, g, _, p, u[y + 12], 6, 1700485571), p = n(p, d, g, _, u[y + 3], 10, 2399980690), _ = n(_, p, d, g, u[y + 10], 15, 4293915773), g = n(g, _, p, d, u[y + 1], 21, 2240044497), d = n(d, g, _, p, u[y + 8], 6, 1873313359), p = n(p, d, g, _, u[y + 15], 10, 4264355552), _ = n(_, p, d, g, u[y + 6], 15, 2734768916), g = n(g, _, p, d, u[y + 13], 21, 1309151649), d = n(d, g, _, p, u[y + 4], 6, 4149444226), p = n(p, d, g, _, u[y + 11], 10, 3174756917), _ = n(_, p, d, g, u[y + 2], 15, 718787259), g = n(g, _, p, d, u[y + 9], 21, 3951481745), d = d + B >>> 0, g = g + rt >>> 0, _ = _ + kt >>> 0, p = p + Qt >>> 0;
    }
    var H = new String(a(d) + a(g) + a(_) + a(p));
    return H.toHex = function() {
      for (var $ = "", M = 0, ot = H.length; M < ot; ++M) $ += s(H.charCodeAt(M));
      return $;
    }, H;
  }, f = l.fromUtf8 = function(m) {
    return c(h(m));
  }, S = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function C(m, u) {
    for (var d = ""; --u >= 0; m >>>= 6) d += S.charAt(63 & m);
    return d;
  }
  var k = [0, 6, 12, 1, 7, 13, 2, 8, 14, 3, 9, 15, 4, 10, 5, 11], L = l.salt = function(m) {
    var u = "";
    m || (m = 8);
    do
      u += S.charAt(64 * Math.random() >>> 0);
    while (--m);
    return u;
  };
  return l.crypt = function(m, u) {
    if (m.length > 64) throw Error("too long key");
    u || (u = "$1$" + L()), m = h(m);
    for (var d = h(u.replace(/^\$1\$([^$]+)(?:\$.*)?$/, "$1")), g = c(m + d + m), _ = m + "$1$" + d, p = m.length; p > 16; p -= 16) _ += g;
    for (_ += g.slice(0, p), p = m.length; p; p >>= 1) _ += 1 & p ? "\0" : m.charAt(0);
    g = c(_);
    for (var y = 0; y < 1e3; ++y) g = c((1 & y ? m : g) + (y % 3 ? d : "") + (y % 7 ? m : "") + (1 & y ? g : m));
    var T = "$1$" + d + "$";
    for (y = 0; y < 15; y += 3) T += C(g.charCodeAt(k[y + 0]) << 16 | g.charCodeAt(k[y + 1]) << 8 | g.charCodeAt(k[y + 2]), 4);
    return T + C(g.charCodeAt(k[15]), 2);
  }, ee.exports;
})();
const Ls = it(As), Is = `-PM${(function(i) {
  const t = i.split(".");
  return `${t[0].padStart(2, "0")}${t[1].padStart(2, "0")}`;
})("2.2.2")}-`, Es = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
function et(i) {
  return `${i.type}-${i.index}`;
}
function pn(i) {
  const { externalId: t } = i;
  return `(${et(i.stream)} | ${t})`;
}
function On(i, t) {
  t ??= i.reduce((s, o) => s + o.byteLength, 0);
  const e = new Uint8Array(t);
  let n = 0;
  for (const s of i) e.set(s, n), n += s.byteLength;
  return e;
}
function fn(i) {
  const t = new TextEncoder(), e = new Uint8Array(i.length);
  return t.encodeInto(i, e), e;
}
function* _n(i) {
  for (let t = i.length - 1; t >= 0; t--) yield i[t];
}
function Dn(i) {
  return !!i && typeof i == "object" && !Array.isArray(i);
}
function tt(i) {
  if ((function(t) {
    return Array.isArray(t);
  })(i)) return i.map((t) => tt(t));
  if (Dn(i)) {
    const t = {};
    for (const e of Object.keys(i)) t[e] = tt(i[e]);
    return t;
  }
  return i;
}
function yt(i, t, e = {}) {
  return typeof i != "object" || i === null || typeof t != "object" || t === null || Object.keys(t).forEach((n) => {
    const s = typeof n == "symbol" ? n.toString() : String(n);
    if (n === "__proto__" || n === "constructor" || n === "prototype") throw new Error(`Attempt to modify restricted property '${s}'`);
    const o = t[n], a = e[n];
    n in i && (i[n] = o === void 0 ? a === void 0 ? void 0 : a : o);
  }), i;
}
function ne(i) {
  const { defaultConfig: t, baseConfig: e = {}, specificStreamConfig: n = {} } = i, s = tt({ ...t, ...e, ...n }), o = Object.keys(t), a = {};
  return o.forEach((h) => {
    h in s && (a[h] = s[h]);
  }), a;
}
var X = ((i) => (i[i.SegmentsAnnouncement = 0] = "SegmentsAnnouncement", i[i.SegmentRequest = 1] = "SegmentRequest", i[i.SegmentData = 2] = "SegmentData", i[i.SegmentDataSendingCompleted = 3] = "SegmentDataSendingCompleted", i[i.SegmentAbsent = 4] = "SegmentAbsent", i[i.CancelSegmentRequest = 5] = "CancelSegmentRequest", i))(X || {}), dt = ((i) => (i[i.Min = -1] = "Min", i[i.Int = 0] = "Int", i[i.SimilarIntArray = 1] = "SimilarIntArray", i[i.String = 2] = "String", i[i.Max = 3] = "Max", i))(dt || {});
function Rs(i) {
  const t = i < 0, e = (function(o) {
    const a = o.toString(2), h = o < 0 ? a.length : a.length + 1;
    return Math.ceil(h / 8);
  })(i), n = new Uint8Array(e), s = BigInt(e);
  i = (function(o) {
    return o < 0 ? -o : o;
  })(i);
  for (let o = 0; o < e; o++) {
    const a = i >> 8n * (s - 1n - BigInt(o)) & 0xffn;
    n[o] = Number(a);
  }
  return t && (n[0] = 128 | n[0]), n;
}
function Ps(i) {
  const t = BigInt(i.length), e = (s, o) => {
    const a = 8n * (t - 1n - BigInt(o));
    return BigInt(s) << a;
  };
  let n = e(127 & i[0], 0);
  for (let s = 1; s < t; s++) n = e(i[s], s) | n;
  return (128 & i[0]) >> 7 && (n = -n), n;
}
function yn(i) {
  const t = Rs(i), e = 0 | t.length;
  return new Uint8Array([e, ...t]);
}
function Nn(i) {
  const t = i[0];
  if (t >> 4 !== 0) throw new Error("Trying to deserialize integer with invalid serialized item code");
  const e = 15 & t, n = 1 + e;
  return { number: Ps(i.slice(1, n)), byteLength: e + 1 };
}
function Bs(i) {
  const [t, e] = i;
  if (t >> 4 !== 1) throw new Error("Trying to deserialize similar int array with invalid serialized item code");
  let n = 2;
  const s = [];
  for (let o = 0; o < e; o++) {
    const { number: a, byteLength: h } = Nn(i.slice(n));
    n += h;
    const l = 0xffn & a, c = -256n & a;
    for (let f = 0; f < l; f++) {
      const S = BigInt(i[n]);
      s.push(c | S), n++;
    }
  }
  return { numbers: s, byteLength: n };
}
function qs(i) {
  const [t, e] = i;
  if (t >> 4 !== 2) throw new Error("Trying to deserialize bytes (sting) with invalid serialized item code.");
  const n = (15 & t) << 8 | e, s = i.slice(2, n + 2);
  return { string: new TextDecoder("utf8").decode(s), byteLength: n + 2 };
}
class wt {
  bytes = [];
  _length = 0;
  push(t) {
    this.addBytes(t, "end");
  }
  unshift(t) {
    this.addBytes(t, "start");
  }
  addBytes(t, e) {
    let n;
    n = t instanceof Uint8Array ? t : Array.isArray(t) ? new Uint8Array(t) : new Uint8Array([t]), this._length += n.length, this.bytes[e === "start" ? "unshift" : "push"](n);
  }
  getBytesChunks() {
    return this.bytes;
  }
  getBuffer() {
    return On(this.bytes, this._length);
  }
  get length() {
    return this._length;
  }
}
const ut = Wt("cstr", 4), vt = Wt("cend", 4), fe = Wt("dstr", 4), _e = Wt("dend", 4), Os = [ut, fe], Ds = [vt, _e], Sn = ut.length + vt.length;
function Mn(i) {
  const { length: t } = ut, e = i.slice(-t);
  return Os.some((n) => $t(i, n, 4)) && Ds.some((n) => $t(e, n, 4));
}
class Ht extends Error {
  constructor(t) {
    super(), this.type = t;
  }
}
class Fn {
  constructor(t) {
    this.onComplete = t;
  }
  chunks = new wt();
  status = "joining";
  addCommandChunk(t) {
    if (this.status === "completed") return;
    const e = $t(t, ut, 4);
    if (!this.chunks.length && !e) throw new Ht("no-first-chunk");
    if (this.chunks.length && e) throw new Ht("incomplete-joining");
    this.chunks.push(this.unframeCommandChunk(t)), (function(n) {
      return $t(n.slice(-4), vt, 4);
    })(t) && (this.status = "completed", this.onComplete(this.chunks.getBuffer()));
  }
  unframeCommandChunk(t) {
    return t.slice(4, t.length - 4);
  }
}
class Et {
  constructor(t, e) {
    this.maxChunkLength = e, this.bytes.push(t);
  }
  bytes = new wt();
  resultBuffers = [];
  status = "creating";
  addInteger(t, e) {
    this.bytes.push(t.charCodeAt(0));
    const n = yn(BigInt(e));
    this.bytes.push(n);
  }
  addSimilarIntArr(t, e) {
    this.bytes.push(t.charCodeAt(0));
    const n = (function(s) {
      const o = /* @__PURE__ */ new Map();
      for (const h of s) {
        const l = -256n & h, c = 0xffn & h, f = o.get(l) ?? new wt();
        f.length || o.set(l, f), f.push(Number(c));
      }
      const a = new wt();
      a.push([16, o.size]);
      for (const [h, l] of o) {
        const { length: c } = l.getBytesChunks(), f = h | 0xffn & BigInt(c);
        l.unshift(yn(f)), a.push(l.getBuffer());
      }
      return a.getBuffer();
    })(e.map((s) => BigInt(s)));
    this.bytes.push(n);
  }
  addString(t, e) {
    this.bytes.push(t.charCodeAt(0));
    const n = (function(s) {
      const { length: o } = s, a = new wt();
      return a.push([32 | o >> 8 & 15, 255 & o]), a.push(new TextEncoder().encode(s)), a.getBuffer();
    })(e);
    this.bytes.push(n);
  }
  complete() {
    if (!this.bytes.length) throw new Error("Buffer is empty");
    if (this.status === "completed") return;
    this.status = "completed";
    const t = this.bytes.getBuffer();
    if (t.length + Sn <= this.maxChunkLength) return void this.resultBuffers.push(Rt(t, ut, vt));
    let e = Math.ceil(t.length / this.maxChunkLength);
    Math.ceil(t.length / e) + Sn > this.maxChunkLength && e++;
    for (const [n, s] of (function* (o, a) {
      const h = Math.ceil(o.length / a);
      for (let l = 0; l < a; l++) yield [l, o.slice(l * h, (l + 1) * h)];
    })(t, e)) n === 0 ? this.resultBuffers.push(Rt(s, ut, _e)) : n === e - 1 ? this.resultBuffers.push(Rt(s, fe, vt)) : this.resultBuffers.push(Rt(s, fe, _e));
  }
  getResultBuffers() {
    if (this.status === "creating" || !this.resultBuffers.length) throw new Error("Command is not complete.");
    return this.resultBuffers;
  }
}
function Un(i) {
  const [t] = i, e = { c: t };
  let n = 1;
  for (; n < i.length; ) {
    const s = String.fromCharCode(i[n]);
    switch (n++, Ns(i[n])) {
      case dt.Int:
        {
          const { number: o, byteLength: a } = Nn(i.slice(n));
          e[s] = Number(o), n += a;
        }
        break;
      case dt.SimilarIntArray:
        {
          const { numbers: o, byteLength: a } = Bs(i.slice(n));
          e[s] = o.map((h) => Number(h)), n += a;
        }
        break;
      case dt.String: {
        const { string: o, byteLength: a } = qs(i.slice(n));
        e[s] = o, n += a;
      }
    }
  }
  return e;
}
function Ns(i) {
  const t = i >> 4;
  if (t <= dt.Min || t >= dt.Max) throw new Error("Not existing type");
  return t;
}
function Wt(i, t) {
  if (i.length !== t) throw new Error("Wrong string length");
  const e = new Uint8Array(t);
  for (let n = 0; n < i.length; n++) e[n] = i.charCodeAt(n);
  return e;
}
function Rt(i, t, e) {
  const n = new Uint8Array(i.length + t.length + e.length);
  return n.set(t), n.set(i, t.length), n.set(e, t.length + i.length), n;
}
function $t(i, t, e) {
  for (let n = 0; n < e; n++) if (i[n] !== t[n]) return !1;
  return !0;
}
function Hn(i, t) {
  switch (i.c) {
    case X.CancelSegmentRequest:
    case X.SegmentAbsent:
    case X.SegmentDataSendingCompleted:
      return (function(e, n) {
        const s = new Et(e.c, n);
        return s.addInteger("i", e.i), s.addInteger("r", e.r), s.complete(), s.getResultBuffers();
      })(i, t);
    case X.SegmentRequest:
      return (function(e, n) {
        const s = new Et(e.c, n);
        return s.addInteger("i", e.i), s.addInteger("r", e.r), e.b && s.addInteger("b", e.b), s.complete(), s.getResultBuffers();
      })(i, t);
    case X.SegmentsAnnouncement:
      return (function(e, n) {
        const { c: s, p: o, l: a } = e, h = new Et(s, n);
        return a?.length && h.addSimilarIntArr("l", a), o?.length && h.addSimilarIntArr("p", o), h.complete(), h.getResultBuffers();
      })(i, t);
    case X.SegmentData:
      return (function(e, n) {
        const s = new Et(e.c, n);
        return s.addInteger("i", e.i), s.addInteger("s", e.s), s.addInteger("r", e.r), s.complete(), s.getResultBuffers();
      })(i, t);
  }
}
const Ms = Object.freeze(Object.defineProperty({ __proto__: null, BinaryCommandChunksJoiner: Fn, BinaryCommandJoiningError: Ht, PeerCommandType: X, deserializeCommand: Un, isCommandChunk: Mn, serializePeerCommand: Hn }, Symbol.toStringTag, { value: "Module" }));
class Fs {
  constructor(t, e, n, s) {
    this.connection = t, this.peerConfig = e, this.eventHandlers = n, this.onChunkDownloaded = s.getEventDispatcher("onChunkDownloaded"), this.onChunkUploaded = s.getEventDispatcher("onChunkUploaded"), t.on("data", this.onDataReceived);
  }
  commandChunks;
  uploadingContext;
  onChunkDownloaded;
  onChunkUploaded;
  onDataReceived = (t) => {
    Mn(t) ? this.receivingCommandBytes(t) : (this.eventHandlers.onSegmentChunkReceived(t), this.onChunkDownloaded(t.byteLength, "p2p", this.connection.idUtf8));
  };
  sendCommand(t) {
    const e = Hn(t, this.peerConfig.webRtcMaxMessageSize);
    for (const n of e) this.connection.write(n);
  }
  stopUploadingSegmentData() {
    this.uploadingContext?.stopUploading(), this.uploadingContext = void 0;
  }
  getUploadingRequestId() {
    return this.uploadingContext?.requestId;
  }
  async splitSegmentDataToChunksAndUploadAsync(t, e) {
    if (this.uploadingContext) throw new Error("Some segment data is already uploading.");
    const n = (function* (f, S) {
      let C = f.byteLength;
      for (; C > 0; ) {
        const k = C >= S ? S : C, L = f.byteLength - C, m = f.slice(L, L + k);
        C -= k, yield m;
      }
    })(t, this.peerConfig.webRtcMaxMessageSize), { promise: s, resolve: o, reject: a } = (function() {
      let f, S;
      return { promise: new Promise((C, k) => {
        f = C, S = k;
      }), resolve: f, reject: S };
    })();
    let h = !1;
    const l = { stopUploading: () => {
      h = !1;
    }, requestId: e };
    this.uploadingContext = l;
    const c = () => {
      if (h) for (; ; ) {
        const f = n.next().value;
        if (!f) {
          o();
          break;
        }
        const S = this.connection.write(f);
        if (this.onChunkUploaded(f.byteLength, this.connection.idUtf8), !S) break;
      }
      else a();
    };
    try {
      this.connection.on("drain", c), h = !0, c(), await s;
    } finally {
      this.connection.off("drain", c), this.uploadingContext === l && (this.uploadingContext = void 0);
    }
  }
  receivingCommandBytes(t) {
    this.commandChunks ??= new Fn((e) => {
      this.commandChunks = void 0;
      const n = Un(e);
      this.eventHandlers.onCommandReceived(n);
    });
    try {
      this.commandChunks.addCommandChunk(t);
    } catch (e) {
      if (!(e instanceof Ht)) return;
      this.commandChunks = void 0;
    }
  }
}
const { PeerCommandType: O } = Ms;
class jt {
  constructor(t, e, n, s, o) {
    this.connection = t, this.eventHandlers = e, this.peerConfig = n, this.streamType = s, this.eventTarget = o, this.onPeerClosed = o.getEventDispatcher("onPeerClose"), this.id = jt.getPeerIdFromConnection(t), this.peerProtocol = new Fs(t, n, { onSegmentChunkReceived: this.onSegmentChunkReceived, onCommandReceived: this.onCommandReceived }, o), o.getEventDispatcher("onPeerConnect")({ peerId: this.id, streamType: s }), t.on("error", this.onConnectionError), t.on("close", this.onPeerConnectionClosed), t.on("end", this.onPeerConnectionClosed), t.on("finish", this.onPeerConnectionClosed);
  }
  id;
  peerProtocol;
  downloadingContext;
  loadedSegments = /* @__PURE__ */ new Set();
  httpLoadingSegments = /* @__PURE__ */ new Set();
  downloadingErrors = [];
  logger = U("p2pml-core:peer");
  onPeerClosed;
  get downloadingSegment() {
    return this.downloadingContext?.request.segment;
  }
  getSegmentStatus(t) {
    const { externalId: e } = t;
    return this.loadedSegments.has(e) ? "loaded" : this.httpLoadingSegments.has(e) ? "http-loading" : void 0;
  }
  onCommandReceived = async (t) => {
    switch (t.c) {
      case O.SegmentsAnnouncement:
        this.loadedSegments = new Set(t.l), this.httpLoadingSegments = new Set(t.p), this.eventHandlers.onSegmentsAnnouncement();
        break;
      case O.SegmentRequest:
        this.peerProtocol.stopUploadingSegmentData(), this.eventHandlers.onSegmentRequested(this, t.i, t.r, t.b);
        break;
      case O.SegmentData:
        {
          if (!this.downloadingContext || this.downloadingContext.isSegmentDataCommandReceived) break;
          const { request: e, controls: n, requestId: s } = this.downloadingContext;
          if (e.segment.externalId !== t.i || s !== t.r) break;
          this.downloadingContext.isSegmentDataCommandReceived = !0, n.firstBytesReceived(), e.totalBytes === void 0 ? e.setTotalBytes(t.s) : e.totalBytes - e.loadedBytes !== t.s && (e.clearLoadedBytes(), this.sendCancelSegmentRequestCommand(e.segment, s), this.cancelSegmentDownloading("peer-response-bytes-length-mismatch"), this.destroy());
        }
        break;
      case O.SegmentDataSendingCompleted: {
        const { downloadingContext: e } = this;
        if (!e?.isSegmentDataCommandReceived) return;
        const { request: n, controls: s } = e;
        if (e.request.segment.externalId !== t.i || e.requestId !== t.r) return n.clearLoadedBytes(), this.cancelSegmentDownloading("peer-protocol-violation"), void this.destroy();
        if (n.loadedBytes !== n.totalBytes) return n.clearLoadedBytes(), this.cancelSegmentDownloading("peer-response-bytes-length-mismatch"), void this.destroy();
        const o = await this.peerConfig.validateP2PSegment?.(n.segment.url, n.segment.byteRange, n.data) ?? !0;
        if (this.downloadingContext !== e) return;
        if (!o) return n.clearLoadedBytes(), this.cancelSegmentDownloading("p2p-segment-validation-failed"), void this.destroy();
        this.downloadingErrors = [], s.completeOnSuccess(), this.downloadingContext = void 0;
        break;
      }
      case O.SegmentAbsent:
        this.downloadingContext?.request.segment.externalId === t.i && this.downloadingContext.requestId === t.r && (this.cancelSegmentDownloading("peer-segment-absent"), this.loadedSegments.delete(t.i));
        break;
      case O.CancelSegmentRequest:
        if (this.peerProtocol.getUploadingRequestId() !== t.r) break;
        this.peerProtocol.stopUploadingSegmentData();
        break;
    }
  };
  onSegmentChunkReceived = (t) => {
    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;
    const { request: e, controls: n } = this.downloadingContext;
    if (e.totalBytes !== void 0 && e.loadedBytes + t.byteLength > e.totalBytes) return e.clearLoadedBytes(), this.cancelSegmentDownloading("peer-response-bytes-length-mismatch"), void this.destroy();
    n.addLoadedChunk(t);
  };
  downloadSegment(t) {
    if (this.downloadingContext) throw new Error("Some segment already is downloading");
    this.downloadingContext = { request: t, requestId: Math.floor(1e3 * Math.random()), isSegmentDataCommandReceived: !1, controls: t.start({ downloadSource: "p2p", peerId: this.id }, { notReceivingBytesTimeoutMs: this.peerConfig.p2pNotReceivingBytesTimeoutMs, abort: (n) => {
      if (!this.downloadingContext) return;
      const { request: s, requestId: o } = this.downloadingContext;
      this.sendCancelSegmentRequestCommand(s.segment, o), this.downloadingErrors.push(n), this.downloadingContext = void 0, this.downloadingErrors.filter((a) => a.type === "bytes-receiving-timeout").length >= this.peerConfig.p2pErrorRetries && this.destroy();
    } }) };
    const e = { c: O.SegmentRequest, r: this.downloadingContext.requestId, i: t.segment.externalId };
    t.loadedBytes && (e.b = t.loadedBytes), this.peerProtocol.sendCommand(e);
  }
  async uploadSegmentData(t, e, n) {
    const { externalId: s } = t;
    this.logger(`send segment ${t.externalId} to ${this.id}`);
    const o = { c: O.SegmentData, i: s, r: e, s: n.byteLength };
    this.peerProtocol.sendCommand(o);
    try {
      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(n, e), this.sendSegmentDataSendingCompletedCommand(t, e), this.logger(`segment ${s} has been sent to ${this.id}`);
    } catch {
      this.logger(`cancel segment uploading ${s}`);
    }
  }
  cancelSegmentDownloading(t) {
    if (!this.downloadingContext) return;
    const { request: e, controls: n } = this.downloadingContext, { segment: s } = e;
    this.logger(`cancel segment request ${s.externalId} (${t})`);
    const o = new D(t);
    n.abortOnError(o), this.downloadingContext = void 0, this.downloadingErrors.push(o);
  }
  sendSegmentsAnnouncementCommand(t, e) {
    const n = { c: O.SegmentsAnnouncement, p: e, l: t };
    this.peerProtocol.sendCommand(n);
  }
  sendSegmentAbsentCommand(t, e) {
    this.peerProtocol.sendCommand({ c: O.SegmentAbsent, i: t, r: e });
  }
  sendCancelSegmentRequestCommand(t, e) {
    this.peerProtocol.sendCommand({ c: O.CancelSegmentRequest, i: t.externalId, r: e });
  }
  sendSegmentDataSendingCompletedCommand(t, e) {
    this.peerProtocol.sendCommand({ c: O.SegmentDataSendingCompleted, r: e, i: t.externalId });
  }
  onPeerConnectionClosed = () => {
    this.destroy();
  };
  onConnectionError = (t) => {
    this.logger(`peer connection error ${this.id} %O`, t), this.eventTarget.getEventDispatcher("onPeerError")({ peerId: this.id, streamType: this.streamType, error: t });
    const { code: e } = t;
    (e === "ERR_DATA_CHANNEL" || e === "ERR_CONNECTION_FAILURE") && this.destroy();
  };
  destroy = () => {
    this.cancelSegmentDownloading("peer-closed"), this.connection.destroy(), this.eventHandlers.onPeerClosed(this), this.onPeerClosed({ peerId: this.id, streamType: this.streamType }), this.logger(`peer closed ${this.id}`);
  };
  static getPeerIdFromConnection(t) {
    return (function(e) {
      const n = new Uint8Array(e.length / 2);
      for (let s = 0; s < e.length; s += 2) n[s / 2] = parseInt(e.slice(s, s + 2), 16);
      return new TextDecoder().decode(n);
    })(t.id);
  }
}
function Us() {
  const i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), t = /\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
  return i || t;
}
class ct {
  constructor(t, e, n, s, o) {
    this.stream = e, this.eventHandlers = n, this.config = s, this.eventTarget = o;
    const a = (function(l) {
      const c = Ls.fromUtf8(l).slice(1);
      return btoa(c);
    })(t);
    this.streamShortId = et(e);
    let h = ct.PEER_ID_BY_INFO_HASH.get(a);
    h || (h = (function(l) {
      const c = [l], f = 20 - l.length;
      for (let S = 0; S < f; S++) c.push(Es[Math.floor(62 * Math.random())]);
      return c.join("");
    })(s.trackerClientVersionPrefix), ct.PEER_ID_BY_INFO_HASH.set(a, h)), this.client = new pe({ infoHash: fn(a), peerId: fn(h), announce: Us() ? s.announceTrackers.slice(0, 1) : s.announceTrackers, rtcConfig: this.config.rtcConfig }), this.client.on("peer", this.onReceivePeerConnection), this.client.on("warning", this.onTrackerClientWarning), this.client.on("error", this.onTrackerClientError), this.logger(`create new client; 
stream: ${this.streamShortId}; hash: ${a}
peerId: ${h}`);
  }
  static PEER_ID_BY_INFO_HASH = /* @__PURE__ */ new Map();
  streamShortId;
  client;
  _peers = /* @__PURE__ */ new Map();
  logger = U("p2pml-core:p2p-tracker-client");
  start() {
    this.client.start();
  }
  destroy() {
    this.client.destroy();
    for (const { peer: t, potentialConnections: e } of this._peers.values()) {
      t?.destroy();
      for (const n of e) n.destroy();
    }
    this._peers.clear(), this.logger("destroy client; stream:", this.streamShortId);
  }
  onReceivePeerConnection = (t) => {
    const e = jt.getPeerIdFromConnection(t);
    let n = this._peers.get(e);
    n?.peer ? t.destroy() : (n || (n = { potentialConnections: /* @__PURE__ */ new Set() }, t.idUtf8 = e, this._peers.set(e, n)), n.potentialConnections.add(t), t.on("connect", () => {
      if (!n.peer) {
        for (const s of n.potentialConnections) s !== t && s.destroy();
        n.potentialConnections.clear(), n.peer = new jt(t, { onPeerClosed: this.onPeerClosed, onSegmentRequested: this.eventHandlers.onSegmentRequested, onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement }, this.config, this.stream.type, this.eventTarget), this.logger(`connected with peer: ${n.peer.id} ${this.streamShortId}`), this.eventHandlers.onPeerConnected(n.peer);
      }
    }));
  };
  onTrackerClientWarning = (t) => {
    this.logger("tracker warning %s:", this.streamShortId, t), this.eventTarget.getEventDispatcher("onTrackerWarning")({ streamType: this.stream.type, warning: t });
  };
  onTrackerClientError = (t) => {
    this.logger("tracker error in stream %s:", this.streamShortId, t), this.eventTarget.getEventDispatcher("onTrackerError")({ streamType: this.stream.type, error: t });
  };
  *peers() {
    for (const t of this._peers.values()) t.peer && (yield t.peer);
  }
  onPeerClosed = (t) => {
    this.logger(`peer closed: ${t.id}`), this._peers.delete(t.id);
  };
  static clearPeerIdCache() {
    ct.PEER_ID_BY_INFO_HASH.clear();
  }
}
function J(i, t) {
  return `v2-${i}-${(function(e) {
    return `${e.type}-${e.index}`;
  })(t)}`;
}
function wn(i, t) {
  for (const e of i.values()) {
    const n = e.segments.get(t);
    if (n) return n;
  }
}
function se(i, t, e, n, s) {
  const { highDemandTimeWindow: o, httpDownloadTimeWindow: a, p2pDownloadTimeWindow: h } = (function(l, c) {
    const { highDemandTimeWindow: f, httpDownloadTimeWindow: S, p2pDownloadTimeWindow: C } = l, k = { highDemandTimeWindow: f, httpDownloadTimeWindow: S, p2pDownloadTimeWindow: C };
    return c <= 5 ? (k.httpDownloadTimeWindow = 0, k.p2pDownloadTimeWindow = 0) : c <= 10 && (k.p2pDownloadTimeWindow = k.httpDownloadTimeWindow), k;
  })(e, s);
  return { isHighDemand: ie(i, t, o), isHttpDownloadable: ie(i, t, a), isP2PDownloadable: ie(i, t, h) && n.isSegmentLoadingOrLoadedBySomeone(i) };
}
function ie(i, t, e) {
  const { startTime: n, endTime: s } = i, { position: o, rate: a } = t;
  return !(o + e * a < n || o > s);
}
class Hs {
  constructor(t, e, n, s, o, a, h) {
    this.streamManifestUrl = t, this.stream = e, this.requests = n, this.segmentStorage = s, this.config = o, this.eventTarget = a, this.onSegmentAnnouncement = h;
    const l = J(this.config.swarmId ?? this.streamManifestUrl, this.stream);
    this.trackerClient = new ct(l, this.stream, { onPeerConnected: this.onPeerConnected, onSegmentRequested: this.onSegmentRequested, onSegmentsAnnouncement: this.onSegmentAnnouncement }, this.config, this.eventTarget), this.eventTarget.addEventListener(`onStorageUpdated-${l}`, this.broadcastAnnouncement), this.segmentStorage.setSegmentChangeCallback((c) => {
      this.eventTarget.dispatchEvent(`onStorageUpdated-${c}`);
    }), this.trackerClient.start();
  }
  trackerClient;
  isAnnounceMicrotaskCreated = !1;
  downloadSegment(t) {
    const e = [];
    for (const a of this.trackerClient.peers()) a.downloadingSegment || a.getSegmentStatus(t) !== "loaded" || e.push(a);
    if (e.length === 0) return;
    const n = (s = e)[Math.floor(Math.random() * s.length)];
    var s;
    const o = this.requests.getOrCreateRequest(t);
    n.downloadSegment(o);
  }
  isSegmentLoadingOrLoadedBySomeone(t) {
    for (const e of this.trackerClient.peers()) if (e.getSegmentStatus(t)) return !0;
    return !1;
  }
  isSegmentLoadedBySomeone(t) {
    for (const e of this.trackerClient.peers()) if (e.getSegmentStatus(t) === "loaded") return !0;
    return !1;
  }
  get connectedPeerCount() {
    let t = 0;
    const e = this.trackerClient.peers();
    for (; !e.next().done; ) t++;
    return t;
  }
  getSegmentsAnnouncement() {
    const t = this.config.swarmId ?? this.streamManifestUrl, e = J(t, this.stream), n = this.segmentStorage.getStoredSegmentIds(t, e), s = [];
    for (const o of this.requests.httpRequests()) {
      const a = this.stream.segments.get(o.segment.runtimeId);
      a && s.push(a.externalId);
    }
    return { loaded: n, httpLoading: s };
  }
  onPeerConnected = (t) => {
    if (this.config.isP2PUploadDisabled) return;
    const { httpLoading: e, loaded: n } = this.getSegmentsAnnouncement();
    t.sendSegmentsAnnouncementCommand(n, e);
  };
  broadcastAnnouncement = (t = !1) => {
    if (t) return void this.sendSegmentsAnnouncement([], []);
    if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) return;
    const { loaded: e, httpLoading: n } = this.getSegmentsAnnouncement();
    this.sendSegmentsAnnouncement(e, n);
  };
  sendSegmentsAnnouncement = (t, e) => {
    this.isAnnounceMicrotaskCreated = !0, queueMicrotask(() => {
      for (const n of this.trackerClient.peers()) n.sendSegmentsAnnouncementCommand(t, e);
      this.isAnnounceMicrotaskCreated = !1;
    });
  };
  onSegmentRequested = async (t, e, n, s) => {
    const o = (function(c, f) {
      for (const S of c.segments.values()) if (S.externalId === f) return S;
    })(this.stream, e);
    if (!o) return;
    if (this.config.isP2PUploadDisabled) return void t.sendSegmentAbsentCommand(e, n);
    const a = this.config.swarmId ?? this.streamManifestUrl, h = J(a, this.stream), l = await this.segmentStorage.getSegmentData(a, h, o.externalId);
    l ? await t.uploadSegmentData(o, n, s !== void 0 ? l.slice(s) : l) : t.sendSegmentAbsentCommand(e, n);
  };
  destroy() {
    const t = J(this.config.swarmId ?? this.streamManifestUrl, this.stream);
    this.eventTarget.removeEventListener(`onStorageUpdated-${t}`, this.broadcastAnnouncement), this.trackerClient.destroy();
  }
}
class $s {
  constructor(t, e, n, s, o, a, h) {
    this.streamManifestUrl = t, this.requests = n, this.segmentStorage = s, this.config = o, this.eventTarget = a, this.onSegmentAnnouncement = h, this._currentLoaderItem = this.findOrCreateLoaderForStream(e), this.logger(`set current p2p loader: ${et(e)}`);
  }
  loaders = /* @__PURE__ */ new Map();
  _currentLoaderItem;
  logger = U("p2pml-core:p2p-loaders-container");
  createLoader(t) {
    if (this.loaders.has(t.runtimeId)) throw new Error("Loader for this stream already exists");
    const e = new Hs(this.streamManifestUrl, t, this.requests, this.segmentStorage, this.config, this.eventTarget, () => {
      this._currentLoaderItem.loader === e && this.onSegmentAnnouncement();
    }), n = et(t);
    return this.logger(`created new loader: ${n}`), { loader: e, stream: t, loggerInfo: et(t) };
  }
  findOrCreateLoaderForStream(t) {
    const e = this.loaders.get(t.runtimeId);
    if (e) return clearTimeout(e.destroyTimeoutId), e.destroyTimeoutId = void 0, e;
    {
      const n = this.createLoader(t);
      return this.loaders.set(t.runtimeId, n), n;
    }
  }
  changeCurrentLoader(t) {
    const e = this.config.swarmId ?? this.streamManifestUrl, n = J(e, this._currentLoaderItem.stream);
    this.segmentStorage.getStoredSegmentIds(e, n).length ? this.setLoaderDestroyTimeout(this._currentLoaderItem) : this.destroyAndRemoveLoader(this._currentLoaderItem), this._currentLoaderItem = this.findOrCreateLoaderForStream(t), this.logger(`change current p2p loader: ${et(t)}`);
  }
  setLoaderDestroyTimeout(t) {
    t.destroyTimeoutId = window.setTimeout(() => this.destroyAndRemoveLoader(t), this.config.p2pInactiveLoaderDestroyTimeoutMs);
  }
  destroyAndRemoveLoader(t) {
    t.loader.destroy(), this.loaders.delete(t.stream.runtimeId), this.logger("destroy p2p loader: ", t.loggerInfo);
  }
  get currentLoader() {
    return this._currentLoaderItem.loader;
  }
  destroy() {
    for (const { loader: t, destroyTimeoutId: e } of this.loaders.values()) t.destroy(), clearTimeout(e);
    this.loaders.clear();
  }
}
function Pt(i) {
  return { runtimeId: i.runtimeId, externalId: i.externalId, url: i.url, byteRange: i.byteRange, startTime: i.startTime, endTime: i.endTime };
}
let js = class {
  constructor(i, t, e, n, s, o) {
    this.segment = i, this.requestProcessQueueCallback = t, this.bandwidthCalculators = e, this.playback = n, this.playbackConfig = s, this.onSegmentError = o.getEventDispatcher("onSegmentError"), this.onSegmentAbort = o.getEventDispatcher("onSegmentAbort"), this.onSegmentStart = o.getEventDispatcher("onSegmentStart"), this.onSegmentLoaded = o.getEventDispatcher("onSegmentLoaded");
    const { byteRange: a } = this.segment;
    if (a) {
      const { end: l, start: c } = a;
      this._totalBytes = l - c + 1;
    }
    this.notReceivingBytesTimeout = new Qs(this.abortOnTimeout);
    const { type: h } = this.segment.stream;
    this._logger = U(`p2pml-core:request-${h}`);
  }
  currentAttempt;
  _failedAttempts = new Ws();
  finalData;
  bytes = [];
  _loadedBytes = 0;
  _totalBytes;
  _status = "not-started";
  progress;
  notReceivingBytesTimeout;
  _abortRequestCallback;
  _logger;
  _isHandledByProcessQueue = !1;
  onSegmentError;
  onSegmentAbort;
  onSegmentStart;
  onSegmentLoaded;
  clearLoadedBytes() {
    this._loadedBytes = 0, this.bytes = [], this._totalBytes = void 0, this.finalData = void 0;
  }
  get status() {
    return this._status;
  }
  setStatus(i) {
    this._status = i, this._isHandledByProcessQueue = !1;
  }
  get downloadSource() {
    return this.currentAttempt?.downloadSource;
  }
  get loadedBytes() {
    return this._loadedBytes;
  }
  get totalBytes() {
    return this._totalBytes;
  }
  get data() {
    return this.finalData ??= On(this.bytes).buffer, this.finalData;
  }
  get failedAttempts() {
    return this._failedAttempts;
  }
  get isHandledByProcessQueue() {
    return this._isHandledByProcessQueue;
  }
  markHandledByProcessQueue() {
    this._isHandledByProcessQueue = !0;
  }
  setTotalBytes(i) {
    if (this._totalBytes !== void 0) throw new Error("Request total bytes value is already set");
    this._totalBytes = i;
  }
  start(i, t) {
    if (this._status === "succeed") throw new Error(`Request ${this.segment.externalId} has been already succeed.`);
    if (this._status === "loading") throw new Error(`Request ${this.segment.externalId} has been already started.`);
    this.setStatus("loading"), this.currentAttempt = { ...i }, this.progress = { startFromByte: this._loadedBytes, loadedBytes: 0, startTimestamp: performance.now() }, this.manageBandwidthCalculatorsState("start");
    const { notReceivingBytesTimeoutMs: e, abort: n } = t;
    return this._abortRequestCallback = n, e !== void 0 && this.notReceivingBytesTimeout.start(e), this.logger(`${i.downloadSource} ${this.segment.externalId} started`), this.onSegmentStart({ segment: Pt(this.segment), downloadSource: i.downloadSource, peerId: i.downloadSource === "p2p" ? i.peerId : void 0 }), { firstBytesReceived: this.firstBytesReceived, addLoadedChunk: this.addLoadedChunk, completeOnSuccess: this.completeOnSuccess, abortOnError: this.abortOnError };
  }
  abortFromProcessQueue() {
    this.throwErrorIfNotLoadingStatus(), this.setStatus("aborted"), this.logger(`${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`), this._abortRequestCallback?.(new D("abort")), this.onSegmentAbort({ segment: Pt(this.segment), downloadSource: this.currentAttempt?.downloadSource, peerId: this.currentAttempt?.downloadSource === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this._abortRequestCallback = void 0, this.manageBandwidthCalculatorsState("stop"), this.notReceivingBytesTimeout.clear();
  }
  abortOnTimeout = () => {
    if (this.throwErrorIfNotLoadingStatus(), !this.currentAttempt) return;
    this.setStatus("failed");
    const i = new D("bytes-receiving-timeout");
    this._abortRequestCallback?.(i), this.logger(`${this.downloadSource} ${this.segment.externalId} failed ${i.type}`), this._failedAttempts.add({ ...this.currentAttempt, error: i }), this.onSegmentError({ segment: Pt(this.segment), error: i, downloadSource: this.currentAttempt.downloadSource, peerId: this.currentAttempt.downloadSource === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this.notReceivingBytesTimeout.clear(), this.manageBandwidthCalculatorsState("stop"), this.requestProcessQueueCallback();
  };
  abortOnError = (i) => {
    this.throwErrorIfNotLoadingStatus(), this.currentAttempt && (this.setStatus("failed"), this.logger(`${this.downloadSource} ${this.segment.externalId} failed ${i.type}`), this._failedAttempts.add({ ...this.currentAttempt, error: i }), this.onSegmentError({ segment: Pt(this.segment), error: i, downloadSource: this.currentAttempt.downloadSource, peerId: this.currentAttempt.downloadSource === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this.notReceivingBytesTimeout.clear(), this.manageBandwidthCalculatorsState("stop"), this.requestProcessQueueCallback());
  };
  completeOnSuccess = () => {
    this.throwErrorIfNotLoadingStatus(), this.currentAttempt && (this.manageBandwidthCalculatorsState("stop"), this.notReceivingBytesTimeout.clear(), this.setStatus("succeed"), this._totalBytes = this._loadedBytes, this.onSegmentLoaded({ segmentUrl: this.segment.url, bytesLength: this.data.byteLength, downloadSource: this.currentAttempt.downloadSource, peerId: this.currentAttempt.downloadSource === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this.logger(`${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`), this.requestProcessQueueCallback());
  };
  addLoadedChunk = (i) => {
    if (this.throwErrorIfNotLoadingStatus(), !this.currentAttempt || !this.progress) return;
    this.notReceivingBytesTimeout.restart();
    const { byteLength: t } = i, { all: e, http: n } = this.bandwidthCalculators;
    e.addBytes(t), this.currentAttempt.downloadSource === "http" && n.addBytes(t), this.bytes.push(i), this.progress.lastLoadedChunkTimestamp = performance.now(), this.progress.loadedBytes += t, this._loadedBytes += t;
  };
  firstBytesReceived = () => {
    this.throwErrorIfNotLoadingStatus(), this.notReceivingBytesTimeout.restart();
  };
  throwErrorIfNotLoadingStatus() {
    if (this._status !== "loading") throw new Error(`Request has been already ${this.status}.`);
  }
  logger(i) {
    this._logger.color = this.currentAttempt?.downloadSource === "http" ? "green" : "red", this._logger(i), this._logger.color = "";
  }
  manageBandwidthCalculatorsState(i) {
    const { all: t, http: e } = this.bandwidthCalculators, n = i === "start" ? "startLoading" : "stopLoading";
    this.currentAttempt?.downloadSource === "http" && e[n](), t[n]();
  }
};
class Ws {
  attempts = [];
  add(t) {
    this.attempts.push(t);
  }
  get httpAttemptsCount() {
    return this.attempts.reduce((t, e) => e.downloadSource === "http" ? t + 1 : t, 0);
  }
  get lastAttempt() {
    return this.attempts[this.attempts.length - 1];
  }
  clear() {
    this.attempts = [];
  }
}
class Qs {
  constructor(t) {
    this.action = t;
  }
  timeoutId;
  ms;
  start(t) {
    if (this.timeoutId) throw new Error("Timeout is already started.");
    this.ms = t, this.timeoutId = window.setTimeout(this.action, this.ms);
  }
  restart(t) {
    this.timeoutId && clearTimeout(this.timeoutId), t && (this.ms = t), this.ms && (this.timeoutId = window.setTimeout(this.action, this.ms));
  }
  clear() {
    clearTimeout(this.timeoutId), this.timeoutId = void 0;
  }
}
class zs {
  constructor(t, e, n, s, o) {
    this.requestProcessQueueCallback = t, this.bandwidthCalculators = e, this.playback = n, this.config = s, this.eventTarget = o;
  }
  requests = /* @__PURE__ */ new Map();
  get executingHttpCount() {
    let t = 0;
    for (const e of this.httpRequests()) e.status === "loading" && t++;
    return t;
  }
  get executingP2PCount() {
    let t = 0;
    for (const e of this.p2pRequests()) e.status === "loading" && t++;
    return t;
  }
  get(t) {
    return this.requests.get(t);
  }
  getOrCreateRequest(t) {
    let e = this.requests.get(t);
    return e || (e = new js(t, this.requestProcessQueueCallback, this.bandwidthCalculators, this.playback, this.config, this.eventTarget), this.requests.set(t, e)), e;
  }
  remove(t) {
    this.requests.delete(t.segment);
  }
  items() {
    return this.requests.values();
  }
  *httpRequests() {
    for (const t of this.requests.values()) t.downloadSource === "http" && (yield t);
  }
  *p2pRequests() {
    for (const t of this.requests.values()) t.downloadSource === "p2p" && (yield t);
  }
  destroy() {
    for (const t of this.requests.values()) t.status === "loading" && t.abortFromProcessQueue();
    this.requests.clear();
  }
}
class Gs {
  constructor(t, e) {
    this.segment = t, this.engineCallbacks = e;
  }
  _status = "pending";
  _shouldBeStartedImmediately = !1;
  get status() {
    return this._status;
  }
  get shouldBeStartedImmediately() {
    return this._shouldBeStartedImmediately;
  }
  resolve(t, e) {
    this._status === "pending" && (this._status = "succeed", this.engineCallbacks.onSuccess({ data: t, bandwidth: e }));
  }
  reject() {
    this._status === "pending" && (this._status = "failed", this.engineCallbacks.onError(new Oe("failed")));
  }
  abort() {
    this._status === "pending" && (this._status = "aborted", this.engineCallbacks.onError(new Oe("aborted")));
  }
  markAsShouldBeStartedImmediately() {
    this._shouldBeStartedImmediately = !0;
  }
}
function* bn(i, t, e, n, s) {
  const { runtimeId: o, stream: a } = i, h = a.segments.get(o);
  if (!h) return;
  const l = a.segments.values();
  let c;
  do {
    const S = l.next();
    if (S.done) return;
    c = S.value;
  } while (c !== h);
  const f = se(c, t, e, n, s);
  if (re(f)) {
    const S = l.next();
    if (S.done) return;
    const C = S.value, k = se(C, t, e, n, s);
    if (re(k)) return;
    f.isHighDemand = !0, yield { segment: c, statuses: f }, yield { segment: C, statuses: k };
  } else yield { segment: c, statuses: f };
  for (const S of l) {
    const C = se(S, t, e, n, s);
    if (re(C)) break;
    yield { segment: S, statuses: C };
  }
}
function re(i) {
  const { isHighDemand: t = !1, isHttpDownloadable: e = !1, isP2PDownloadable: n = !1 } = i;
  return !t && !e && !n;
}
class Ys {
  constructor(t, e, n, s, o, a, h) {
    this.streamManifestUrl = t, this.lastRequestedSegment = e, this.streamDetails = n, this.config = s, this.bandwidthCalculators = o, this.segmentStorage = a, this.eventTarget = h;
    const l = this.lastRequestedSegment.stream;
    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 }, this.segmentAvgDuration = (function(c) {
      const { segments: f } = c;
      let S = 0;
      const { size: C } = f;
      for (const k of f.values()) S += k.endTime - k.startTime;
      return S / C;
    })(l), this.requests = new zs(this.requestProcessQueueMicrotask, this.bandwidthCalculators, this.playback, this.config, this.eventTarget), this.p2pLoaders = new $s(this.streamManifestUrl, this.lastRequestedSegment.stream, this.requests, this.segmentStorage, this.config, this.eventTarget, this.requestProcessQueueMicrotask), this.logger = U(`p2pml-core:hybrid-loader-${l.type}`), this.logger.color = "coral", this.setIntervalLoading();
  }
  requests;
  engineRequest;
  p2pLoaders;
  playback;
  segmentAvgDuration;
  logger;
  storageCleanUpIntervalId;
  levelChangedTimestamp;
  lastQueueProcessingTimeStamp;
  randomHttpDownloadInterval;
  isProcessQueueMicrotaskCreated = !1;
  setIntervalLoading() {
    const t = this.p2pLoaders.currentLoader.connectedPeerCount, e = 1e3 * Math.random() * t + 1e3;
    this.randomHttpDownloadInterval = window.setTimeout(() => {
      this.loadRandomThroughHttp(), this.setIntervalLoading();
    }, e);
  }
  async loadSegment(t, e) {
    this.logger(`requests: ${pn(t)}`);
    const { stream: n } = t;
    n !== this.lastRequestedSegment.stream && (this.logger(`stream changed to ${et(n)}`), this.p2pLoaders.changeCurrentLoader(n)), this.lastRequestedSegment = t;
    const s = this.config.swarmId ?? this.streamManifestUrl, o = J(s, n);
    this.segmentStorage.onSegmentRequested(s, o, t.externalId, t.startTime, t.endTime, n.type, this.streamDetails.isLive);
    const a = new Gs(t, e);
    try {
      if (this.segmentStorage.hasSegment(s, o, t.externalId)) {
        const h = await this.segmentStorage.getSegmentData(s, o, t.externalId);
        if (h) {
          const { queueDownloadRatio: l } = this.generateQueue();
          return void a.resolve(h, this.getBandwidth(l));
        }
      }
      this.engineRequest?.abort(), this.engineRequest = a;
    } catch {
      a.reject();
    } finally {
      this.requestProcessQueueMicrotask();
    }
  }
  requestProcessQueueMicrotask = (t = !0) => {
    const e = performance.now();
    !t && this.lastQueueProcessingTimeStamp !== void 0 && e - this.lastQueueProcessingTimeStamp <= 1e3 || this.isProcessQueueMicrotaskCreated || (this.isProcessQueueMicrotaskCreated = !0, queueMicrotask(() => {
      try {
        this.processQueue(), this.lastQueueProcessingTimeStamp = e;
      } finally {
        this.isProcessQueueMicrotaskCreated = !1;
      }
    }));
  };
  processRequests(t, e) {
    const { stream: n } = this.lastRequestedSegment, { httpErrorRetries: s } = this.config, o = performance.now();
    for (const a of this.requests.items()) {
      const { downloadSource: h, status: l, segment: c, isHandledByProcessQueue: f } = a, S = this.engineRequest?.segment === c ? this.engineRequest : void 0;
      switch (l) {
        case "loading":
          t.has(c.runtimeId) || S || (a.abortFromProcessQueue(), this.requests.remove(a));
          break;
        case "succeed": {
          if (!h) break;
          h === "http" && this.p2pLoaders.currentLoader.broadcastAnnouncement(), S && (S.resolve(a.data, this.getBandwidth(e)), this.engineRequest = void 0), this.requests.remove(a);
          const k = this.config.swarmId ?? this.streamManifestUrl, L = J(k, n);
          this.segmentStorage.storeSegment(k, L, c.externalId, a.data, c.startTime, c.endTime, c.stream.type, this.streamDetails.isLive);
          break;
        }
        case "failed":
          h !== "http" || f || this.p2pLoaders.currentLoader.broadcastAnnouncement(), S || n.segments.has(a.segment.runtimeId) || this.requests.remove(a), a.failedAttempts.httpAttemptsCount >= s && S && (this.engineRequest = void 0, S.reject());
          break;
        case "not-started":
        case "aborted":
          this.requests.remove(a);
      }
      a.markHandledByProcessQueue();
      const { lastAttempt: C } = a.failedAttempts;
      C && o - C.error.timestamp > 6e4 && a.failedAttempts.clear();
    }
  }
  processQueue() {
    const { queue: t, queueSegmentIds: e, queueDownloadRatio: n } = this.generateQueue();
    this.processRequests(e, n);
    const { simultaneousHttpDownloads: s, simultaneousP2PDownloads: o, httpErrorRetries: a } = this.config;
    if (this.engineRequest?.shouldBeStartedImmediately && this.engineRequest.status === "pending" && this.requests.executingHttpCount < s) {
      const { segment: h } = this.engineRequest, l = this.requests.get(h);
      (!l || l.status === "not-started" || l.status === "failed" && l.failedAttempts.httpAttemptsCount < this.config.httpErrorRetries) && this.loadThroughHttp(h);
    }
    for (const h of t) {
      const { statuses: l, segment: c } = h, f = this.requests.get(c);
      if (l.isHighDemand) {
        if (f?.downloadSource === "http" && f.status === "loading" || f?.downloadSource === "http" && f.status === "failed" && f.failedAttempts.httpAttemptsCount >= a) continue;
        const S = f?.status === "loading" && f.downloadSource === "p2p";
        if (this.requests.executingHttpCount < s) {
          S && f.abortFromProcessQueue(), this.loadThroughHttp(c);
          continue;
        }
        if (this.abortLastHttpLoadingInQueueAfterItem(t, c) && this.requests.executingHttpCount < s) {
          S && f.abortFromProcessQueue(), this.loadThroughHttp(c);
          continue;
        }
        if (S) continue;
        if (this.requests.executingP2PCount < o) {
          this.loadThroughP2P(c);
          continue;
        }
        if (this.abortLastP2PLoadingInQueueAfterItem(t, c) && this.requests.executingP2PCount < o) {
          this.loadThroughP2P(c);
          continue;
        }
      } else if (l.isP2PDownloadable) {
        if (f?.status === "loading") continue;
        (this.requests.executingP2PCount < o || this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(c) && this.abortLastP2PLoadingInQueueAfterItem(t, c) && this.requests.executingP2PCount < o) && this.loadThroughP2P(c);
      }
    }
  }
  abortSegmentRequest(t) {
    this.engineRequest?.segment.runtimeId === t && (this.engineRequest.abort(), this.logger("abort: ", pn(this.engineRequest.segment)), this.engineRequest = void 0, this.requestProcessQueueMicrotask());
  }
  loadThroughHttp(t) {
    const e = this.requests.getOrCreateRequest(t);
    new as(e, this.config, this.eventTarget), this.p2pLoaders.currentLoader.broadcastAnnouncement();
  }
  loadThroughP2P(t) {
    this.p2pLoaders.currentLoader.downloadSegment(t);
  }
  loadRandomThroughHttp() {
    const t = this.getAvailableStorageCapacityPercent();
    if (t <= 10) return;
    const { simultaneousHttpDownloads: e, httpErrorRetries: n } = this.config, s = this.p2pLoaders.currentLoader;
    if (this.requests.executingHttpCount >= e || !s.connectedPeerCount) return;
    const o = [];
    for (const { segment: f, statuses: S } of bn(this.lastRequestedSegment, this.playback, this.config, this.p2pLoaders.currentLoader, t)) {
      const C = this.config.swarmId ?? this.streamManifestUrl, k = J(C, f.stream);
      if (!S.isHttpDownloadable || S.isP2PDownloadable || this.segmentStorage.hasSegment(C, k, f.externalId)) continue;
      const L = this.requests.get(f);
      L && (L.status === "loading" || L.status === "succeed" || L.failedAttempts.httpAttemptsCount >= n) || o.push(f);
    }
    if (!o.length || e - this.requests.executingHttpCount === 0) return;
    const a = s.connectedPeerCount + 1, h = Math.min(o.length, e * a), l = (function(f) {
      for (let S = f.length - 1; S > 0; S--) {
        const C = Math.floor(Math.random() * (S + 1));
        [f[S], f[C]] = [f[C], f[S]];
      }
      return f;
    })(Array.from({ length: h }, (f, S) => S));
    let c = h / a;
    for (const f of l) {
      if (this.requests.executingHttpCount >= e) break;
      if (c >= 1 || Math.random() <= c) {
        const S = o[f];
        this.loadThroughHttp(S);
      }
      if (c--, c <= 0) break;
    }
  }
  abortLastHttpLoadingInQueueAfterItem(t, e) {
    for (const { segment: n } of _n(t)) {
      if (n === e) break;
      const s = this.requests.get(n);
      if (s?.downloadSource === "http" && s.status === "loading") return s.abortFromProcessQueue(), !0;
    }
    return !1;
  }
  abortLastP2PLoadingInQueueAfterItem(t, e) {
    for (const { segment: n } of _n(t)) {
      if (n === e) break;
      const s = this.requests.get(n);
      if (s?.downloadSource === "p2p" && s.status === "loading") return s.abortFromProcessQueue(), !0;
    }
    return !1;
  }
  getAvailableStorageCapacityPercent() {
    const { totalCapacity: t, usedCapacity: e } = this.segmentStorage.getUsage();
    return 100 - e / t * 100;
  }
  generateQueue() {
    const t = [], e = /* @__PURE__ */ new Set();
    let n = 0, s = 0;
    const o = this.getAvailableStorageCapacityPercent();
    for (const a of bn(this.lastRequestedSegment, this.playback, this.config, this.p2pLoaders.currentLoader, o)) {
      n++;
      const { segment: h } = a, l = this.config.swarmId ?? this.streamManifestUrl, c = J(l, h.stream);
      this.segmentStorage.hasSegment(l, c, h.externalId) || this.requests.get(h)?.status === "succeed" ? s++ : (t.push(a), e.add(h.runtimeId));
    }
    return { queue: t, queueSegmentIds: e, maxPossibleLength: n, alreadyLoadedCount: s, queueDownloadRatio: n !== 0 ? s / n : 0 };
  }
  getBandwidth(t) {
    const { http: e, all: n } = this.bandwidthCalculators, { activeLevelBitrate: s } = this.streamDetails;
    if (this.streamDetails.activeLevelBitrate === 0) return n.getBandwidthLoadingOnly(3);
    const o = Math.max(n.getBandwidth(30, this.levelChangedTimestamp), n.getBandwidth(60, this.levelChangedTimestamp), n.getBandwidth(90, this.levelChangedTimestamp));
    if (t >= 0.8 || o >= 0.9 * s) return Math.max(n.getBandwidthLoadingOnly(1), n.getBandwidthLoadingOnly(3), n.getBandwidthLoadingOnly(5));
    const a = Math.max(e.getBandwidthLoadingOnly(1), e.getBandwidthLoadingOnly(3), e.getBandwidthLoadingOnly(5));
    return Math.max(o, a);
  }
  notifyLevelChanged() {
    this.levelChangedTimestamp = performance.now();
  }
  sendBroadcastAnnouncement(t = !1) {
    this.p2pLoaders.currentLoader.broadcastAnnouncement(t);
  }
  updatePlayback(t, e) {
    const n = this.playback.rate !== e, s = this.playback.position !== t;
    if (!n && !s) return;
    const o = Math.abs(t - this.playback.position) / this.segmentAvgDuration > 0.5;
    s && (this.playback.position = t), n && e !== 0 && (this.playback.rate = e), o && (this.logger("position significantly changed"), this.engineRequest?.markAsShouldBeStartedImmediately()), this.segmentStorage.onPlaybackUpdated(t, e), this.requestProcessQueueMicrotask(o);
  }
  updateStream(t) {
    t === this.lastRequestedSegment.stream && (this.logger(`update stream: ${et(t)}`), this.requestProcessQueueMicrotask());
  }
  destroy() {
    clearInterval(this.storageCleanUpIntervalId), clearInterval(this.randomHttpDownloadInterval), this.storageCleanUpIntervalId = void 0, this.engineRequest?.abort(), this.requests.destroy(), this.p2pLoaders.destroy();
  }
}
class Cn {
  constructor(t = 2e4) {
    this.clearThresholdMs = t;
  }
  loadingsCount = 0;
  bytes = [];
  loadingOnlyTimestamps = [];
  timestamps = [];
  noLoadingsTime = 0;
  loadingsStoppedAt = 0;
  addBytes(t, e = performance.now()) {
    this.bytes.push(t), this.loadingOnlyTimestamps.push(e - this.noLoadingsTime), this.timestamps.push(e);
  }
  startLoading(t = performance.now()) {
    this.clearStale(), this.loadingsCount === 0 && this.loadingsStoppedAt !== 0 && (this.noLoadingsTime += t - this.loadingsStoppedAt), this.loadingsCount++;
  }
  stopLoading(t = performance.now()) {
    this.loadingsCount > 0 && (this.loadingsCount--, this.loadingsCount === 0 && (this.loadingsStoppedAt = t));
  }
  getBandwidthLoadingOnly(t, e = Number.NEGATIVE_INFINITY) {
    if (!this.loadingOnlyTimestamps.length) return 0;
    const n = 1e3 * t, s = this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];
    let o = s;
    const a = s - n;
    let h = 0;
    for (let l = this.bytes.length - 1; l >= 0; l--) {
      const c = this.loadingOnlyTimestamps[l];
      if (c < a || this.timestamps[l] < e) break;
      o = c, h += this.bytes[l];
    }
    return 8e3 * h / (s - o);
  }
  getBandwidth(t, e = Number.NEGATIVE_INFINITY, n = performance.now()) {
    if (!this.timestamps.length) return 0;
    const s = n - 1e3 * t;
    let o = n, a = 0;
    for (let h = this.bytes.length - 1; h >= 0; h--) {
      const l = this.timestamps[h];
      if (l < s || l < e) break;
      o = l, a += this.bytes[h];
    }
    return 8e3 * a / (n - o);
  }
  clearStale() {
    if (!this.loadingOnlyTimestamps.length) return;
    const t = this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] - this.clearThresholdMs;
    let e = 0;
    for (const n of this.loadingOnlyTimestamps) {
      if (n > t) break;
      e++;
    }
    this.bytes.splice(0, e), this.loadingOnlyTimestamps.splice(0, e), this.timestamps.splice(0, e);
  }
}
const Bt = (i, t) => `${i}|${t}`, qt = 1048576;
class Js {
  userAgent = navigator.userAgent;
  segmentMemoryStorageLimit = 4096;
  currentStorageUsage = 0;
  cache = /* @__PURE__ */ new Map();
  logger;
  coreConfig;
  mainStreamConfig;
  secondaryStreamConfig;
  currentPlayback;
  lastRequestedSegment;
  segmentChangeCallback;
  constructor() {
    this.logger = U("p2pml-core:segment-memory-storage"), this.logger.color = "RebeccaPurple";
  }
  async initialize(t, e, n) {
    this.coreConfig = t, this.mainStreamConfig = e, this.secondaryStreamConfig = n, this.setMemoryStorageLimit(), this.logger("initialized");
  }
  onPlaybackUpdated(t, e) {
    this.currentPlayback = { position: t, rate: e };
  }
  onSegmentRequested(t, e, n, s, o, a, h) {
    this.lastRequestedSegment = { streamId: e, segmentId: n, startTime: s, endTime: o, swarmId: t, streamType: a, isLiveStream: h };
  }
  async storeSegment(t, e, n, s, o, a, h, l) {
    this.clear(l, s.byteLength);
    const c = Bt(e, n);
    if (this.cache.set(c, { data: s, segmentId: n, streamId: e, startTime: o, endTime: a, streamType: h }), this.increaseStorageUsage(s.byteLength), this.logger(`add segment: ${n} to ${e}`), !this.segmentChangeCallback) throw new Error("dispatchStorageUpdatedEvent is not set");
    this.segmentChangeCallback(e);
  }
  async getSegmentData(t, e, n) {
    const s = Bt(e, n), o = this.cache.get(s);
    if (o !== void 0) return o.data;
  }
  getUsage() {
    if (!this.lastRequestedSegment || !this.currentPlayback) return { totalCapacity: this.segmentMemoryStorageLimit, usedCapacity: this.currentStorageUsage };
    const t = this.currentPlayback.position;
    let e = 0;
    for (const { endTime: n, data: s } of this.cache.values()) t > n || (e += s.byteLength);
    return { totalCapacity: this.segmentMemoryStorageLimit, usedCapacity: e / qt };
  }
  hasSegment(t, e, n) {
    const s = Bt(e, n);
    return this.cache.get(s) !== void 0;
  }
  getStoredSegmentIds(t, e) {
    const n = [];
    for (const { segmentId: s, streamId: o } of this.cache.values()) o === e && n.push(s);
    return n;
  }
  clear(t, e) {
    if (!(this.currentPlayback && this.mainStreamConfig && this.secondaryStreamConfig && this.coreConfig) || !this.isMemoryLimitReached(e) && !t) return;
    const n = /* @__PURE__ */ new Set(), s = Array.from(this.cache.values()).sort((o, a) => o.startTime - a.startTime);
    for (const o of s) {
      const { streamId: a, segmentId: h, data: l } = o, c = Bt(a, h);
      if (this.shouldRemoveSegment(o, t, this.currentPlayback.position) && (this.cache.delete(c), n.add(a), this.decreaseStorageUsage(l.byteLength), this.logger(`Removed segment ${h} from stream ${a}`), !this.isMemoryLimitReached(e) && !t)) break;
    }
    this.sendUpdatesToAffectedStreams(n);
  }
  isMemoryLimitReached(t) {
    return this.currentStorageUsage + t / qt > this.segmentMemoryStorageLimit;
  }
  setSegmentChangeCallback(t) {
    this.segmentChangeCallback = t;
  }
  sendUpdatesToAffectedStreams(t) {
    t.size !== 0 && t.forEach((e) => {
      if (!this.segmentChangeCallback) throw new Error("dispatchStorageUpdatedEvent is not set");
      this.segmentChangeCallback(e);
    });
  }
  shouldRemoveSegment(t, e, n) {
    const { endTime: s, streamType: o } = t, a = this.getStreamTimeWindow(o, "highDemandTimeWindow");
    return !(n <= s) && (!e || n > a + s);
  }
  increaseStorageUsage(t) {
    this.currentStorageUsage += t / qt;
  }
  decreaseStorageUsage(t) {
    this.currentStorageUsage -= t / qt;
  }
  setMemoryStorageLimit() {
    var t;
    this.coreConfig?.segmentMemoryStorageLimit ? this.segmentMemoryStorageLimit = this.coreConfig.segmentMemoryStorageLimit : (t = this.userAgent, /Android/i.test(t) && !/Chrome|Firefox/i.test(t) || ((e) => /iPad|iPhone/i.test(e))(this.userAgent) ? this.segmentMemoryStorageLimit = 1024 : ((e) => /Android/i.test(e))(this.userAgent) && (this.segmentMemoryStorageLimit = 2048));
  }
  getStreamTimeWindow(t, e) {
    return (t === "main" ? this.mainStreamConfig : this.secondaryStreamConfig)?.[e] ?? 0;
  }
  destroy() {
    this.cache.clear();
  }
}
class Vs {
  events = /* @__PURE__ */ new Map();
  dispatchEvent(t, ...e) {
    const n = this.events.get(t);
    if (n) for (const s of n) s(...e);
  }
  getEventDispatcher(t) {
    let e = this.events.get(t);
    e || (e = [], this.events.set(t, e));
    const n = e;
    return (...s) => {
      for (const o of n) o(...s);
    };
  }
  addEventListener(t, e) {
    const n = this.events.get(t);
    n ? n.push(e) : this.events.set(t, [e]);
  }
  removeEventListener(t, e) {
    const n = this.events.get(t);
    if (n) {
      const s = n.indexOf(e);
      s !== -1 && n.splice(s, 1);
    }
  }
}
class Nt {
  static DEFAULT_COMMON_CORE_CONFIG = { segmentMemoryStorageLimit: void 0, customSegmentStorageFactory: void 0 };
  static DEFAULT_STREAM_CONFIG = { isP2PUploadDisabled: !1, isP2PDisabled: !1, simultaneousHttpDownloads: 2, simultaneousP2PDownloads: 3, highDemandTimeWindow: 15, httpDownloadTimeWindow: 3e3, p2pDownloadTimeWindow: 6e3, webRtcMaxMessageSize: 65535, p2pNotReceivingBytesTimeoutMs: 2e3, p2pInactiveLoaderDestroyTimeoutMs: 3e4, httpNotReceivingBytesTimeoutMs: 3e3, httpErrorRetries: 3, p2pErrorRetries: 3, trackerClientVersionPrefix: Is, announceTrackers: ["wss://tracker.novage.com.ua", "wss://tracker.webtorrent.dev", "wss://tracker.openwebtorrent.com"], rtcConfig: { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:global.stun.twilio.com:3478" }] }, validateP2PSegment: void 0, validateHTTPSegment: void 0, httpRequestSetup: void 0, swarmId: void 0 };
  eventTarget = new Vs();
  manifestResponseUrl;
  streams = /* @__PURE__ */ new Map();
  mainStreamConfig;
  secondaryStreamConfig;
  commonCoreConfig;
  bandwidthCalculators = { all: new Cn(), http: new Cn() };
  segmentStorage;
  mainStreamLoader;
  secondaryStreamLoader;
  streamDetails = { isLive: !1, activeLevelBitrate: 0 };
  constructor(t) {
    const e = (function n(s) {
      if (Dn(s)) {
        const o = {};
        return Object.keys(s).forEach((a) => {
          if (s[a] !== void 0) {
            const h = n(s[a]);
            h !== void 0 && (o[a] = h);
          }
        }), o;
      }
      return s;
    })(t ?? {});
    this.commonCoreConfig = ne({ defaultConfig: Nt.DEFAULT_COMMON_CORE_CONFIG, baseConfig: e }), this.mainStreamConfig = ne({ defaultConfig: Nt.DEFAULT_STREAM_CONFIG, baseConfig: e, specificStreamConfig: e.mainStream }), this.secondaryStreamConfig = ne({ defaultConfig: Nt.DEFAULT_STREAM_CONFIG, baseConfig: e, specificStreamConfig: e.secondaryStream });
  }
  getConfig() {
    return { ...tt(this.commonCoreConfig), mainStream: tt(this.mainStreamConfig), secondaryStream: tt(this.secondaryStreamConfig) };
  }
  applyDynamicConfig(t) {
    const { mainStream: e, secondaryStream: n } = t, s = tt(this.mainStreamConfig), o = tt(this.secondaryStreamConfig);
    this.overrideAllConfigs(t, e, n), this.processSpecificDynamicConfigParams(s, t, "main"), this.processSpecificDynamicConfigParams(o, t, "secondary");
  }
  processSpecificDynamicConfigParams(t, e, n) {
    const s = this.getUpdatedStreamProperty("isP2PDisabled", e, n);
    s && t.isP2PDisabled !== s && this.destroyStreamLoader(n);
    const o = this.getUpdatedStreamProperty("isP2PUploadDisabled", e, n);
    o !== void 0 && t.isP2PUploadDisabled !== o && (n === "main" ? this.mainStreamLoader : this.secondaryStreamLoader)?.sendBroadcastAnnouncement(o);
  }
  getUpdatedStreamProperty(t, e, n) {
    return (n === "main" ? e.mainStream : e.secondaryStream)?.[t] ?? e[t];
  }
  addEventListener(t, e) {
    this.eventTarget.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    this.eventTarget.removeEventListener(t, e);
  }
  setManifestResponseUrl(t) {
    this.manifestResponseUrl = t.split("?")[0];
  }
  hasSegment(t) {
    return !!wn(this.streams, t);
  }
  getStream(t) {
    return this.streams.get(t);
  }
  addStreamIfNoneExists(t) {
    this.streams.has(t.runtimeId) || this.streams.set(t.runtimeId, { ...t, segments: /* @__PURE__ */ new Map() });
  }
  updateStream(t, e, n) {
    const s = this.streams.get(t);
    if (s) {
      if (e) for (const o of e) s.segments.has(o.runtimeId) || s.segments.set(o.runtimeId, { ...o, stream: s });
      if (n) for (const o of n) s.segments.delete(o);
      this.mainStreamLoader?.updateStream(s), this.secondaryStreamLoader?.updateStream(s);
    }
  }
  async loadSegment(t, e) {
    if (!this.manifestResponseUrl) throw new Error("Manifest response url is not defined");
    await this.initializeSegmentStorage();
    const n = this.identifySegment(t);
    this.getStreamHybridLoader(n).loadSegment(n, e);
  }
  abortSegmentLoading(t) {
    this.mainStreamLoader?.abortSegmentRequest(t), this.secondaryStreamLoader?.abortSegmentRequest(t);
  }
  updatePlayback(t, e) {
    this.mainStreamLoader?.updatePlayback(t, e), this.secondaryStreamLoader?.updatePlayback(t, e);
  }
  setActiveLevelBitrate(t) {
    t !== this.streamDetails.activeLevelBitrate && (this.streamDetails.activeLevelBitrate = t, this.mainStreamLoader?.notifyLevelChanged(), this.secondaryStreamLoader?.notifyLevelChanged());
  }
  setIsLive(t) {
    this.streamDetails.isLive = t;
  }
  isSegmentLoadable(t) {
    try {
      const e = this.identifySegment(t);
      return (e.stream.type !== "main" || !this.mainStreamConfig.isP2PDisabled) && (e.stream.type !== "secondary" || !this.secondaryStreamConfig.isP2PDisabled);
    } catch {
      return !1;
    }
  }
  destroy() {
    this.streams.clear(), this.mainStreamLoader?.destroy(), this.secondaryStreamLoader?.destroy(), this.segmentStorage?.destroy(), this.mainStreamLoader = void 0, this.secondaryStreamLoader = void 0, this.segmentStorage = void 0, this.manifestResponseUrl = void 0, this.streamDetails = { isLive: !1, activeLevelBitrate: 0 }, ct.clearPeerIdCache();
  }
  async initializeSegmentStorage() {
    if (this.segmentStorage) return;
    const { isLive: t } = this.streamDetails, e = this.commonCoreConfig.customSegmentStorageFactory;
    if (e && typeof e != "function") throw new Error("Storage configuration is invalid");
    const n = e ? e(t) : new Js();
    await n.initialize(this.commonCoreConfig, this.mainStreamConfig, this.secondaryStreamConfig), this.segmentStorage = n;
  }
  identifySegment(t) {
    if (!this.manifestResponseUrl) throw new Error("Manifest response url is undefined");
    const e = wn(this.streams, t);
    if (!e) throw new Error(`Not found segment with id: ${t}`);
    return e;
  }
  overrideAllConfigs(t, e, n) {
    yt(this.commonCoreConfig, t), yt(this.mainStreamConfig, t), yt(this.secondaryStreamConfig, t), e && yt(this.mainStreamConfig, e), n && yt(this.secondaryStreamConfig, n);
  }
  destroyStreamLoader(t) {
    t === "main" ? (this.mainStreamLoader?.destroy(), this.mainStreamLoader = void 0) : (this.secondaryStreamLoader?.destroy(), this.secondaryStreamLoader = void 0);
  }
  getStreamHybridLoader(t) {
    return t.stream.type === "main" ? (this.mainStreamLoader ??= this.createNewHybridLoader(t), this.mainStreamLoader) : (this.secondaryStreamLoader ??= this.createNewHybridLoader(t), this.secondaryStreamLoader);
  }
  createNewHybridLoader(t) {
    if (!this.manifestResponseUrl) throw new Error("Manifest response url is not defined");
    if (!this.segmentStorage) throw new Error("Segment storage is not initialized");
    const e = t.stream.type === "main" ? this.mainStreamConfig : this.secondaryStreamConfig;
    return new Ys(this.manifestResponseUrl, t, this.streamDetails, e, this.bandwidthCalculators, this.segmentStorage, this.eventTarget);
  }
}
const Ks = An.debug;
export {
  Nt as Core,
  Oe as CoreRequestError,
  D as RequestError,
  Ks as debug
};
//# sourceMappingURL=p2p-media-loader-core.es.min.js.map
